import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as i,o as t,c as o,a as n,b as l,d as a,e as c}from"./app-hoN0JGLf.js";const r={},p=n("h1",{id:"netty",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#netty"},[n("span",null,"netty")])],-1),d={href:"https://www.jianshu.com/p/12dd57758eb5?utm_source=oschina-app",target:"_blank",rel:"noopener noreferrer"},h=n("h2",{id:"服务器实现",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#服务器实现"},[n("span",null,"服务器实现")])],-1),u=n("h2",{id:"客户端实现",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#客户端实现"},[n("span",null,"客户端实现")])],-1),f={href:"https://blog.csdn.net/q160336802/article/details/123409093",target:"_blank",rel:"noopener noreferrer"},v=c(`<h2 id="原理" tabindex="-1"><a class="header-anchor" href="#原理"><span>原理</span></a></h2><h3 id="缓存区分配" tabindex="-1"><a class="header-anchor" href="#缓存区分配"><span>缓存区分配</span></a></h3><h4 id="类或接口" tabindex="-1"><a class="header-anchor" href="#类或接口"><span>类或接口</span></a></h4><ul><li>ByteBufAllocator</li><li>RecvByteBufAllocator</li><li>RecvByteBufAllocator.Handle</li><li>NioSocketChannelConfig DefaultChannelConfig DefaultChannelConfig、ChannelConfig</li><li>NioByteUnsafe NioByteUnsafe</li><li>NioSocketChannel AbstractNioByteChannel AbstractNioChannel AbstractChannel</li></ul><h4 id="初始化" tabindex="-1"><a class="header-anchor" href="#初始化"><span>初始化</span></a></h4><ul><li>缓存分配器</li><li>缓存分配策略</li></ul><h4 id="fixedrecvbytebufallocator" tabindex="-1"><a class="header-anchor" href="#fixedrecvbytebufallocator"><span>FixedRecvByteBufAllocator</span></a></h4><h4 id="adaptiverecvbytebufallocator" tabindex="-1"><a class="header-anchor" href="#adaptiverecvbytebufallocator"><span>AdaptiveRecvByteBufAllocator</span></a></h4><h3 id="核心类维护" tabindex="-1"><a class="header-anchor" href="#核心类维护"><span>核心类维护</span></a></h3><ul><li>eventLoop维护SocketChannel</li><li>SocketChannel维护Pipeline、UnSafe</li><li>Pipeline维护handlerContext</li><li>handlerContext维护channelHandler</li></ul><h3 id="pipeline如何维护带有channelhandler的context" tabindex="-1"><a class="header-anchor" href="#pipeline如何维护带有channelhandler的context"><span>pipeline如何维护带有channelHandler的Context</span></a></h3><ul><li>pipeline自带HeadContext和TailContext</li><li>维护了自带头尾的上下文链表,pipeline初始化handler就是创建带有channelHandler的Context，并插入到链表头部</li><li>pipeline处理消息时，从尾部上下文到头部上下文执行channelHandler,最终写入到channel</li></ul><h3 id="niounsafe-extends-unsafe-的作用" tabindex="-1"><a class="header-anchor" href="#niounsafe-extends-unsafe-的作用"><span>NioUnsafe extends Unsafe 的作用</span></a></h3><p>定义了处理读取、连接、写入事件的接口方法</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="shiki light-plus" style="background-color:#FFFFFF;color:#000000;" tabindex="0"><code><span class="line"><span style="color:#0000FF;">public</span><span style="color:#0000FF;"> interface</span><span style="color:#267F99;"> NioUnsafe</span><span style="color:#0000FF;"> extends</span><span style="color:#267F99;"> Unsafe</span><span style="color:#000000;"> {</span></span>
<span class="line"><span style="color:#008000;">  /**</span></span>
<span class="line"><span style="color:#008000;">   * Return underlying</span></span>
<span class="line"><span style="color:#008000;">   */</span></span>
<span class="line"><span style="color:#267F99;">  SelectableChannel</span><span style="color:#795E26;"> ch</span><span style="color:#000000;">();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#008000;">  /**</span></span>
<span class="line"><span style="color:#008000;">   * Finish connect</span></span>
<span class="line"><span style="color:#008000;">   */</span></span>
<span class="line"><span style="color:#267F99;">  void</span><span style="color:#795E26;"> finishConnect</span><span style="color:#000000;">();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#008000;">  /**</span></span>
<span class="line"><span style="color:#008000;">   * Read from underlying</span></span>
<span class="line"><span style="color:#008000;">   */</span></span>
<span class="line"><span style="color:#267F99;">  void</span><span style="color:#795E26;"> read</span><span style="color:#000000;">();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#267F99;">  void</span><span style="color:#795E26;"> forceFlush</span><span style="color:#000000;">();</span></span>
<span class="line"><span style="color:#000000;">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="connect连接事件的触发" tabindex="-1"><a class="header-anchor" href="#connect连接事件的触发"><span>connect连接事件的触发</span></a></h3><blockquote><p>触发条件</p></blockquote><ul><li>连接有了结果，可能连接上，也可能没连上</li><li>连接过程有了错误</li></ul><blockquote><p>处理流程</p></blockquote><ul><li>需要主动判断连接结果，若失败，则直接抛出异常</li><li>设置SelectionKey的感兴趣事件，去除连接事件，增加读写事件</li></ul><h3 id="感兴趣事件分析" tabindex="-1"><a class="header-anchor" href="#感兴趣事件分析"><span>感兴趣事件分析</span></a></h3><ul><li>补码运算</li><li>符号位参与逻辑运算</li></ul><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="shiki light-plus" style="background-color:#FFFFFF;color:#000000;" tabindex="0"><code><span class="line"><span>00000000 00000000 00000000 00001000 连接</span></span>
<span class="line"><span>11111111 11111111 11111111 11110111 取反</span></span>
<span class="line"><span></span></span>
<span class="line"><span>00000000 00000000 00000000 00001000  连接</span></span>
<span class="line"><span>00000000 00000000 00000000 00000100  写</span></span>
<span class="line"><span>00000000 00000000 00000000 00000001  读</span></span>
<span class="line"><span>00000000 00000000 00000000 00010000  客户端连接</span></span>
<span class="line"><span></span></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="读取事件处理流程" tabindex="-1"><a class="header-anchor" href="#读取事件处理流程"><span>读取事件处理流程</span></a></h3><ul><li>NioEventLoop的processSelectedKey方法</li><li>AbstractNioChannel.NioUnsafe的read方法 <ul><li>从channel获取ChannelConfig、ChannelPipeline</li><li>从ChannelConfig获取ByteBufAllocator、RecvByteBufAllocator</li><li>每次读取创建RecvByteBufAllocator.Handle对象，重置读取字节数和消息数</li><li>分配缓存，读取数据</li><li>交给pipeline处理</li></ul></li></ul><h3 id="写出事件处理流程" tabindex="-1"><a class="header-anchor" href="#写出事件处理流程"><span>写出事件处理流程</span></a></h3><ul><li>channel维护了ChannelOutBoundBuffer</li><li>ChannelOutBoundBuffer维护了写出数据Entry队列</li><li>调用channel的write方法，经过pipeline的handler后增加到ChannelOutBoundBuffer</li><li>当channel有写出事件后，将Entry中的数据写入到javaChannel中</li><li>可控制写出的消息数</li></ul><h3 id="flush分析" tabindex="-1"><a class="header-anchor" href="#flush分析"><span>flush分析</span></a></h3><ul><li>当调用flush时就是将ChannelOutBoundBuffer数据写入到javaChannel中,数据转移</li><li>当javaChannel有空间，则直接写入数据，否则让socketChannel的感兴趣事件包含写事件</li><li>触发可写事件，继续写数据到javaChannel</li><li>直到javaChannel有空间写入，或ChannelOutBoundBuffer缓存区没有数据，取消感兴趣事件</li></ul><h3 id="flushconsolidationhandler" tabindex="-1"><a class="header-anchor" href="#flushconsolidationhandler"><span>FlushConsolidationHandler</span></a></h3><p>控制flush次数，即向底层写数据(系统调用)次数</p><h3 id="客户端初始化" tabindex="-1"><a class="header-anchor" href="#客户端初始化"><span>客户端初始化</span></a></h3><h3 id="服务端初始化" tabindex="-1"><a class="header-anchor" href="#服务端初始化"><span>服务端初始化</span></a></h3><ul><li>channel注册到eventLoop</li></ul>`,34);function y(b,m){const e=i("ExternalLinkIcon");return t(),o("div",null,[p,n("p",null,[n("a",d,[l("事件处理"),a(e)])]),h,u,n("p",null,[n("a",f,[l("参考"),a(e)])]),v])}const x=s(r,[["render",y],["__file","netty.html.vue"]]),B=JSON.parse('{"path":"/note/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/netty.html","title":"netty","lang":"zh-CN","frontmatter":{"description":"netty 事件处理 服务器实现 客户端实现 参考 原理 缓存区分配 类或接口 ByteBufAllocator RecvByteBufAllocator RecvByteBufAllocator.Handle NioSocketChannelConfig DefaultChannelConfig DefaultChannelConfig、Channe...","head":[["meta",{"property":"og:url","content":"https://wherywan.github.io/note/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/netty.html"}],["meta",{"property":"og:site_name","content":"HONG_JI"}],["meta",{"property":"og:title","content":"netty"}],["meta",{"property":"og:description","content":"netty 事件处理 服务器实现 客户端实现 参考 原理 缓存区分配 类或接口 ByteBufAllocator RecvByteBufAllocator RecvByteBufAllocator.Handle NioSocketChannelConfig DefaultChannelConfig DefaultChannelConfig、Channe..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-03-15T07:44:07.000Z"}],["meta",{"property":"article:author","content":"wanhongji"}],["meta",{"property":"article:modified_time","content":"2024-03-15T07:44:07.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"netty\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-03-15T07:44:07.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"wanhongji\\"}]}"]]},"headers":[{"level":2,"title":"服务器实现","slug":"服务器实现","link":"#服务器实现","children":[]},{"level":2,"title":"客户端实现","slug":"客户端实现","link":"#客户端实现","children":[]},{"level":2,"title":"原理","slug":"原理","link":"#原理","children":[{"level":3,"title":"缓存区分配","slug":"缓存区分配","link":"#缓存区分配","children":[]},{"level":3,"title":"核心类维护","slug":"核心类维护","link":"#核心类维护","children":[]},{"level":3,"title":"pipeline如何维护带有channelHandler的Context","slug":"pipeline如何维护带有channelhandler的context","link":"#pipeline如何维护带有channelhandler的context","children":[]},{"level":3,"title":"NioUnsafe extends Unsafe 的作用","slug":"niounsafe-extends-unsafe-的作用","link":"#niounsafe-extends-unsafe-的作用","children":[]},{"level":3,"title":"connect连接事件的触发","slug":"connect连接事件的触发","link":"#connect连接事件的触发","children":[]},{"level":3,"title":"感兴趣事件分析","slug":"感兴趣事件分析","link":"#感兴趣事件分析","children":[]},{"level":3,"title":"读取事件处理流程","slug":"读取事件处理流程","link":"#读取事件处理流程","children":[]},{"level":3,"title":"写出事件处理流程","slug":"写出事件处理流程","link":"#写出事件处理流程","children":[]},{"level":3,"title":"flush分析","slug":"flush分析","link":"#flush分析","children":[]},{"level":3,"title":"FlushConsolidationHandler","slug":"flushconsolidationhandler","link":"#flushconsolidationhandler","children":[]},{"level":3,"title":"客户端初始化","slug":"客户端初始化","link":"#客户端初始化","children":[]},{"level":3,"title":"服务端初始化","slug":"服务端初始化","link":"#服务端初始化","children":[]}]}],"git":{"createdTime":1678009775000,"updatedTime":1710488647000,"contributors":[{"name":"wanhongji","email":"wherywan@163.com","commits":3}]},"readingTime":{"minutes":2.03,"words":610},"filePathRelative":"note/网络通信/netty.md","localizedDate":"2023年3月5日","excerpt":"\\n<p><a href=\\"https://www.jianshu.com/p/12dd57758eb5?utm_source=oschina-app\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">事件处理</a></p>\\n<h2>服务器实现</h2>\\n<h2>客户端实现</h2>\\n<p><a href=\\"https://blog.csdn.net/q160336802/article/details/123409093\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">参考</a></p>\\n<h2>原理</h2>\\n<h3>缓存区分配</h3>","autoDesc":true}');export{x as comp,B as data};
