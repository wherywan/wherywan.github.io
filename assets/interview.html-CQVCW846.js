import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as n,c as a,e}from"./app-hoN0JGLf.js";const i={},l=e(`<h1 id="interview" tabindex="-1"><a class="header-anchor" href="#interview"><span>interview</span></a></h1><h2 id="jvm监控" tabindex="-1"><a class="header-anchor" href="#jvm监控"><span>jvm监控</span></a></h2><p>实际场景，设参，垃圾回收触发时机及条件</p><h2 id="事务传播的具体场景" tabindex="-1"><a class="header-anchor" href="#事务传播的具体场景"><span>事务传播的具体场景</span></a></h2><h2 id="spring线程安全" tabindex="-1"><a class="header-anchor" href="#spring线程安全"><span>spring线程安全</span></a></h2><h2 id="递归算法题" tabindex="-1"><a class="header-anchor" href="#递归算法题"><span>递归算法题</span></a></h2><h2 id="hashtable与hashmap的区别" tabindex="-1"><a class="header-anchor" href="#hashtable与hashmap的区别"><span>hashtable与hashmap的区别</span></a></h2><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="shiki light-plus" style="background-color:#FFFFFF;color:#000000;" tabindex="0"><code><span class="line"><span>hashtable是一个线程安全的类，用于存放键值对。内部的方法都被synchronized修饰</span></span>
<span class="line"><span>hashmap与之相反，键和值可以为null, hashtable不可以用null作为键</span></span>
<span class="line"><span>HashMap的初始容量为16，Hashtable初始容量为11，两者的填充因子默认都是0.75。</span></span>
<span class="line"><span>hashmap的扩容是2的n次方，hashtable是2倍加1</span></span>
<span class="line"><span>使用2的n次方便于使用与运算得到对应的数组散列值或索引</span></span>
<span class="line"><span>在多线程环境下若使用HashMap需要使用Collections.synchronizedMap()方法来获取一个线程安全的集合</span></span>
<span class="line"><span></span></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="string、stringbuffer、stringbuilder" tabindex="-1"><a class="header-anchor" href="#string、stringbuffer、stringbuilder"><span>string、stringbuffer、stringbuilder</span></a></h2><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="shiki light-plus" style="background-color:#FFFFFF;color:#000000;" tabindex="0"><code><span class="line"><span>三者都是用于描述和操作字符串的类</span></span>
<span class="line"><span>stirng是不可变的、其余是可变的</span></span>
<span class="line"><span>stringbuffer和stringbuilder通过append方法在原有内存中的字符串上，改变字符串。</span></span>
<span class="line"><span>stringbuffer是线程安全的</span></span>
<span class="line"><span></span></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="实现对象的克隆" tabindex="-1"><a class="header-anchor" href="#实现对象的克隆"><span>实现对象的克隆</span></a></h2><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="shiki light-plus" style="background-color:#FFFFFF;color:#000000;" tabindex="0"><code><span class="line"><span>可分为浅克隆和深克隆</span></span>
<span class="line"><span>浅克隆通过对象的引用(地址)的传递，辅助的地址，指向同一个对象</span></span>
<span class="line"><span>深克隆</span></span>
<span class="line"><span>1、序列化和反序列化</span></span>
<span class="line"><span>2、实现cloneable接口，表示可克隆，调用object的clone方法，若包含引用对象需调用引用对象的clone方法，赋值。</span></span>
<span class="line"><span></span></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="gc-gc的作用" tabindex="-1"><a class="header-anchor" href="#gc-gc的作用"><span>gc？gc的作用</span></a></h2><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="shiki light-plus" style="background-color:#FFFFFF;color:#000000;" tabindex="0"><code><span class="line"><span>gc即垃圾回收</span></span>
<span class="line"><span>gc可以帮助程序员实现自动内存管理，而不用程序员手动释放内存，提高开发效率。</span></span>
<span class="line"><span>判断对象是否存活的算法：</span></span>
<span class="line"><span>1、可达性分析算法</span></span>
<span class="line"><span>2、引用计数法 python等语言使用进行内存管理</span></span>
<span class="line"><span></span></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="spring支持的事务管理类型-事务传播" tabindex="-1"><a class="header-anchor" href="#spring支持的事务管理类型-事务传播"><span>Spring支持的事务管理类型, 事务传播</span></a></h2><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="shiki light-plus" style="background-color:#FFFFFF;color:#000000;" tabindex="0"><code><span class="line"><span>编程式事务管理，手动提交回滚事务，如下</span></span>
<span class="line"><span>PlatformTransactionManager txmanager</span></span>
<span class="line"><span>TransactionStatus status = txManager.getTransaction(new DefaultTransactionDefinition());</span></span>
<span class="line"><span>txmanager.commit(status)</span></span>
<span class="line"><span>txmanager.rollback(status)</span></span>
<span class="line"><span>声明式事务管理， @Transactional 或xml配置方式</span></span>
<span class="line"><span></span></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="shiki light-plus" style="background-color:#FFFFFF;color:#000000;" tabindex="0"><code><span class="line"><span>事务的传播 7种</span></span>
<span class="line"><span>1、默认required ,如果当前没有事务，就创建一个新事务，如果当前存在事务，就加入该事务。</span></span>
<span class="line"><span>@Transactional(propagation = Propagation.REQUIRED)</span></span>
<span class="line"><span>public void methodA() {</span></span>
<span class="line"><span> methodB();</span></span>
<span class="line"><span>// do something</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>@Transactional(propagation = Propagation.REQUIRED)</span></span>
<span class="line"><span>public void methodB() {</span></span>
<span class="line"><span>    // do something</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>单独调用methodB方法时，因为当前上下文不存在事务，所以会开启一个新的事务。</span></span>
<span class="line"><span>调用methodA方法时，因为当前上下文不存在事务，所以会开启一个新的事务。当执行到methodB时，methodB发现当前上下文有事务，因此就加入到当前事务中来。</span></span>
<span class="line"><span></span></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="什么是cookie-cookie和session的区别" tabindex="-1"><a class="header-anchor" href="#什么是cookie-cookie和session的区别"><span>什么是cookie ，cookie和session的区别</span></a></h2><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="shiki light-plus" style="background-color:#FFFFFF;color:#000000;" tabindex="0"><code><span class="line"><span>cookie是客户端会话技术，用于在客户端存放一些信息，通常用于下次请求，服务端辨别客户身份的方式，如token, 支持跨域,子域名</span></span>
<span class="line"><span>session是服务端会话技术，存放用户信息，返回sessionId存放在cookie中，对用户进行验证</span></span>
<span class="line"><span>cookie存放信息&lt;=4kB</span></span>
<span class="line"><span></span></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="什么情况下发生数据脏读" tabindex="-1"><a class="header-anchor" href="#什么情况下发生数据脏读"><span>什么情况下发生数据脏读</span></a></h2><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="shiki light-plus" style="background-color:#FFFFFF;color:#000000;" tabindex="0"><code><span class="line"><span>事务隔离级别是读未提交</span></span>
<span class="line"><span>线程B读到了线程A未提交的数据</span></span>
<span class="line"><span></span></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="accesslog" tabindex="-1"><a class="header-anchor" href="#accesslog"><span>accesslog</span></a></h2><p>用户每访问一次会在accesslog中记录一次访问记录，找出10次以上的用户</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="shiki light-plus" style="background-color:#FFFFFF;color:#000000;" tabindex="0"><code><span class="line"><span>根据host进行分组 count（*）&gt;10 </span></span>
<span class="line"><span></span></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="生产环境索引失效-解决方案" tabindex="-1"><a class="header-anchor" href="#生产环境索引失效-解决方案"><span>生产环境索引失效，解决方案？</span></a></h2><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="shiki light-plus" style="background-color:#FFFFFF;color:#000000;" tabindex="0"><code><span class="line"><span>explain/analyse分析sql执行计划，看是否用上索引</span></span>
<span class="line"><span>强制使用索引，force index(索引名称)</span></span>
<span class="line"><span>索引失效：</span></span>
<span class="line"><span>模糊查询首部使用了%</span></span>
<span class="line"><span>or</span></span>
<span class="line"><span>隐式类型转换</span></span>
<span class="line"><span>联合索引未遵循最左原则</span></span>
<span class="line"><span>条件中使用了数学计算或函数，如test/2</span></span>
<span class="line"><span></span></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="shiki light-plus" style="background-color:#FFFFFF;color:#000000;" tabindex="0"><code><span class="line"><span>查看慢查询日志是否开启</span></span>
<span class="line"><span>SHOW VARIABLES LIKE &#39;%slow_query_log%&#39;;</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="如何按类型将数据映射到不同的类上" tabindex="-1"><a class="header-anchor" href="#如何按类型将数据映射到不同的类上"><span>如何按类型将数据映射到不同的类上？</span></a></h2><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="shiki light-plus" style="background-color:#FFFFFF;color:#000000;" tabindex="0"><code><span class="line"><span>有待学习</span></span>
<span class="line"><span>可以采用数据字典的方式，在数据库中，类型字段使用整型数据值来标识不同类型</span></span>
<span class="line"><span>在接口中定义枚举类型，定义code和zh含义</span></span>
<span class="line"><span></span></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="如果一个线程发生oom-线程还会运行吗-会影响其他线程吗" tabindex="-1"><a class="header-anchor" href="#如果一个线程发生oom-线程还会运行吗-会影响其他线程吗"><span>如果一个线程发生OOM，线程还会运行吗？会影响其他线程吗？</span></a></h2><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="shiki light-plus" style="background-color:#FFFFFF;color:#000000;" tabindex="0"><code><span class="line"><span>不影响，当一个线程抛出OOM异常后，它所占据的内存资源会全部被释放掉，从而不会影响其他线程的运行！</span></span>
<span class="line"><span>但如果共享变量被其他线程使用，则不会gc，内存释放不了，导致其余线程死亡</span></span>
<span class="line"><span></span></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="如果主线程抛异常退出了-子线程还能运行么" tabindex="-1"><a class="header-anchor" href="#如果主线程抛异常退出了-子线程还能运行么"><span>如果主线程抛异常退出了，子线程还能运行么?</span></a></h2><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="shiki light-plus" style="background-color:#FFFFFF;color:#000000;" tabindex="0"><code><span class="line"><span>线程不像进程，一个进程中的线程之间是没有父子之分的，都是平级关系。即线程都是一样的, 退出了一个不会影响另外一个。</span></span>
<span class="line"><span>如果主线程抛异常退出了，子线程还能运行。</span></span>
<span class="line"><span>但是有一个例外情况，如果这些子线程都是守护线程，那么子线程会随着主线程结束而结束。</span></span>
<span class="line"><span></span></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="如何在springboot启动时-加载资源到内存" tabindex="-1"><a class="header-anchor" href="#如何在springboot启动时-加载资源到内存"><span>如何在springboot启动时，加载资源到内存</span></a></h2><ul><li><p>@postConstruct</p></li><li><p>CommandLineRunner接口</p></li><li><p>static代码块</p></li><li><p>ApplicationListener监听器</p><div class="language-java line-numbers-mode" data-ext="java" data-title="java"><pre class="shiki light-plus" style="background-color:#FFFFFF;color:#000000;" tabindex="0"><code><span class="line"><span style="color:#0000FF;">public</span><span style="color:#0000FF;"> class</span><span style="color:#267F99;"> ApplicationEventListener</span><span style="color:#0000FF;"> implements</span><span style="color:#267F99;"> ApplicationListener</span><span style="color:#000000;">&lt;</span><span style="color:#267F99;">ApplicationEvent</span><span style="color:#000000;">&gt; {</span></span>
<span class="line"><span style="color:#000000;">	@</span><span style="color:#267F99;">Override</span></span>
<span class="line"><span style="color:#0000FF;">    public</span><span style="color:#267F99;"> void</span><span style="color:#795E26;"> onApplicationEvent</span><span style="color:#000000;">(</span><span style="color:#267F99;">ApplicationEvent</span><span style="color:#001080;"> event</span><span style="color:#000000;">) {</span></span>
<span class="line"><span style="color:#000000;">      </span></span>
<span class="line"><span style="color:#000000;">      </span></span>
<span class="line"><span style="color:#000000;">    }</span></span>
<span class="line"><span style="color:#000000;">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>启动类显式调用</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="shiki light-plus" style="background-color:#FFFFFF;color:#000000;" tabindex="0"><code><span class="line"><span>public class StartIiApplication{</span></span>
<span class="line"><span>    public static void main(String[] args) {</span></span>
<span class="line"><span>        ApplicationContext applicationContext =	        	   SpringApplication.run(StartIiApplication.class, args);</span></span>
<span class="line"><span>        BeanUtil.setApplicationContext(applicationContext);    </span></span>
<span class="line"><span>        //从启动的容器中获取Bean，并调用初始化方法</span></span>
<span class="line"><span>       	TestUtils util=(TestUtils) applicationContext.getBean(&quot;testUtils&quot;);</span></span>
<span class="line"><span>        util.Init();</span></span>
<span class="line"><span>    </span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><h2 id="starter的意义" tabindex="-1"><a class="header-anchor" href="#starter的意义"><span>starter的意义</span></a></h2><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="shiki light-plus" style="background-color:#FFFFFF;color:#000000;" tabindex="0"><code><span class="line"><span>主要用于简化spring的繁琐配置，通过构建starter，将组件相关jar包引入，以及通过@configuration注解的配置类，spring.factories文件，在容器启动时，通过自动装配，将相关配置信息注入到spring容器中。</span></span>
<span class="line"><span>spring-boot-starter-data-redis构建redis环境</span></span>
<span class="line"><span>spring-boot-starter-web构建web环境</span></span>
<span class="line"><span></span></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="分布式事务" tabindex="-1"><a class="header-anchor" href="#分布式事务"><span>分布式事务</span></a></h2><blockquote><p>锁和事务的共存的解决方案</p></blockquote><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="shiki light-plus" style="background-color:#FFFFFF;color:#000000;" tabindex="0"><code><span class="line"><span>自动提交事务后释放锁</span></span>
<span class="line"><span>try</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>    tryLock()获取锁</span></span>
<span class="line"><span>    业务处理方法加@Tranctional注解</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>catch</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>	</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>finally</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>	释放锁</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>手动提交事务释放锁</span></span>
<span class="line"><span>try</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>	tryLock()获取锁</span></span>
<span class="line"><span>	业务处理</span></span>
<span class="line"><span>	commit</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>catch</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>	rollback</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>finally</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>	释放锁</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>事务特性</p></blockquote><ul><li><p>本地事务</p><ul><li><p>原子性</p></li><li><p>一致性</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="shiki light-plus" style="background-color:#FFFFFF;color:#000000;" tabindex="0"><code><span class="line"><span>在事务执行前后，数据保持一致</span></span>
<span class="line"><span></span></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li><li><p>隔离性</p></li><li><p>持久性</p></li></ul></li><li><p>分布式事务</p><ul><li><p>一致性</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="shiki light-plus" style="background-color:#FFFFFF;color:#000000;" tabindex="0"><code><span class="line"><span>某项业务操作跨多个服务，要保证多个服务本地事务操作前后数据一致，</span></span>
<span class="line"><span>如一个下单操作，订单服务和库存服务：</span></span>
<span class="line"><span>订单服务创建订单，库存服务扣减库存，在分布式事务执行前后，各服务上的数据要保持一致</span></span>
<span class="line"><span>可分为强一致性和弱一致性</span></span>
<span class="line"><span></span></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="shiki light-plus" style="background-color:#FFFFFF;color:#000000;" tabindex="0"><code><span class="line"><span>弱一致性：发货单保存到es数据库</span></span>
<span class="line"><span>在事务执行完毕,发送消息，异步更新库存，保证更新库存操作是可靠的，但数据在经过一段时间后才能保持一致</span></span>
<span class="line"><span></span></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>可用性</p></li><li><p>兼容性</p></li></ul></li></ul><blockquote><p>分布式事务解决方案</p></blockquote><p>Seata 是一款开源的分布式事务解决方案，致力于提供高性能和简单易用 的分布式事务服务。Seata 将为用户提供了 AT、TCC、SAGA 和 XA 事 务模式，为用户打造一站式的分布式解决方案(AT模式是阿里首推的模式, 阿里云上有商用版本的GTS[Global Transaction service 全局事务服务] ) 。</p><p>1、二阶段提交回滚</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="shiki light-plus" style="background-color:#FFFFFF;color:#000000;" tabindex="0"><code><span class="line"><span>一阶段，即保存了各服务本地事务提交前后的undolog日志，并将本地事务的执行结果告知事务协调者TC</span></span>
<span class="line"><span>二阶段提交，即删除undolog</span></span>
<span class="line"><span>二阶段回滚，根据undolog再次开启本地事务执行回滚操作</span></span>
<span class="line"><span></span></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="熔断降级如何处理" tabindex="-1"><a class="header-anchor" href="#熔断降级如何处理"><span>熔断降级如何处理?</span></a></h2><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="shiki light-plus" style="background-color:#FFFFFF;color:#000000;" tabindex="0"><code><span class="line"><span>hystrix是一个容错组件，实现了超时机制和断路器模式。</span></span>
<span class="line"><span>hystrix提供了熔断和降级。</span></span>
<span class="line"><span># feign 关闭httpclient</span></span>
<span class="line"><span>feign.httpclient.enabled=false</span></span>
<span class="line"><span># feign 启用okhttp</span></span>
<span class="line"><span>feign.okhttp.enabled=true 可以配置拦截器向请求头添加信息</span></span>
<span class="line"><span></span></span>
<span class="line"><span># 单位ms,请求处理的超时时间</span></span>
<span class="line"><span>ribbon.ReadTimeout=15000</span></span>
<span class="line"><span># 单位ms,请求连接超时时间</span></span>
<span class="line"><span>ribbon.ConnectTimeout=5000</span></span>
<span class="line"><span># 对当前实例的重试次数</span></span>
<span class="line"><span>ribbon.MaxAutoRetries=0</span></span>
<span class="line"><span># 切换实例的重试次数</span></span>
<span class="line"><span>ribbon.MaxAutoRetriesNextServer=1</span></span>
<span class="line"><span># 对所有操作请求都进行重试</span></span>
<span class="line"><span>ribbon.OkToRetryOnAllOperations=false</span></span>
<span class="line"><span># 刷新服务列表的间隔时间</span></span>
<span class="line"><span>ribbon.ServerListRefreshInterval=5000  获取服务注册列表</span></span>
<span class="line"><span></span></span>
<span class="line"><span>#feign开启hystrix</span></span>
<span class="line"><span>feign.hystrix.enabled=true</span></span>
<span class="line"><span></span></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p>降级</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="shiki light-plus" style="background-color:#FFFFFF;color:#000000;" tabindex="0"><code><span class="line"><span>降级其实就相当于，当我们向一个服务发起请求，当请求超时了，就会把这次请求记录到服务中，然后就会尝试向其他服务发请求，如果还没成功，就对这次请求进行处理（怎么处理取决于业务需求如）就相当于try catch一样的逻辑，当然hystrix底层使用aop来实现的。</span></span>
<span class="line"><span></span></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li><li><p>隔离和限流</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="shiki light-plus" style="background-color:#FFFFFF;color:#000000;" tabindex="0"><code><span class="line"><span>每当向服务发起一个请求时，就是会发起一个http请求,每一个http请求就要开启一个线程，然后等待服务返回信息，这容易导致线程的堆积，所以就可以用http的URI作为一个标识，然后相同的URI可以开启一个线程池，然后线程池中限定线程数，这样就可以设置拒绝策略，当线程池满了，就可以快速的抛出异常或者拒绝请求，用线程池做到线程隔离来达到限流。</span></span>
<span class="line"><span></span></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li><li><p>熔断</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="shiki light-plus" style="background-color:#FFFFFF;color:#000000;" tabindex="0"><code><span class="line"><span>当达到一定次数不再向服务发起请求，默认20次，且失败率达到50以上，设置服务为关闭，</span></span>
<span class="line"><span>每5秒通过一次请求，看服务是否可用，服务状态更新为启用</span></span>
<span class="line"><span>feign被hystrix包裹</span></span>
<span class="line"><span></span></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><h2 id="jvm参数设置" tabindex="-1"><a class="header-anchor" href="#jvm参数设置"><span>jvm参数设置？</span></a></h2><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="shiki light-plus" style="background-color:#FFFFFF;color:#000000;" tabindex="0"><code><span class="line"><span>设置堆内存大小</span></span>
<span class="line"><span>-Xmx1G  设置最大堆内存</span></span>
<span class="line"><span>-Xms1G	设置最小堆内存</span></span>
<span class="line"><span>-Xmn1200m 设置年轻代大小</span></span>
<span class="line"><span>-Xss 设置线程的堆栈大小</span></span>
<span class="line"><span>-XX:MaxTenuringThreshold=15 设置进入老年代的阈值</span></span>
<span class="line"><span>-XX:+PrintGCDetails</span></span>
<span class="line"><span>-XX:+PrintGCTimeStamps</span></span>
<span class="line"><span>-XX:+PrintGCDateStamps</span></span>
<span class="line"><span>-XX:+PrintTenuringDistribution</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="tomcat容器" tabindex="-1"><a class="header-anchor" href="#tomcat容器"><span>tomcat容器</span></a></h2><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="shiki light-plus" style="background-color:#FFFFFF;color:#000000;" tabindex="0"><code><span class="line"><span>tomcat如何接受请求？</span></span>
<span class="line"><span>acceptCount 操作系统层面判断</span></span>
<span class="line"><span>MaxConnection 在accept之前进行判断</span></span>
<span class="line"><span>acceptor线程，创建socket套接字对象</span></span>
<span class="line"><span>两个poller线程，从队列中取socket套接字加入到select选择器中，调用选择器的select方法获取就绪socket套接字集，进行遍历处理读取解析数据</span></span>
<span class="line"><span></span></span>
<span class="line"><span>请求数过多会导致？</span></span>
<span class="line"><span>acceptCount   connectionrefused</span></span>
<span class="line"><span>MaxConnection 阻塞</span></span>
<span class="line"><span></span></span>
<span class="line"><span>使用了线程池？</span></span>
<span class="line"><span>如果未设置超时时间，会一直等待</span></span>
<span class="line"><span></span></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="如何处理缓存穿透、雪崩、击穿等问题的" tabindex="-1"><a class="header-anchor" href="#如何处理缓存穿透、雪崩、击穿等问题的"><span>如何处理缓存穿透、雪崩、击穿等问题的？</span></a></h2><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="shiki light-plus" style="background-color:#FFFFFF;color:#000000;" tabindex="0"><code><span class="line"><span>缓存击穿</span></span>
<span class="line"><span>热点key过期失效，使用锁，双重检查，第一次查询，从数据库查询数据，设置缓存</span></span>
<span class="line"><span>缓存穿透</span></span>
<span class="line"><span>大量请求查询不存在的key，第一次查询，设置空值</span></span>
<span class="line"><span>缓存雪崩</span></span>
<span class="line"><span>key大面积失效</span></span>
<span class="line"><span>设置不同的过期时间</span></span>
<span class="line"><span></span></span>
<span class="line"><span>其他缓存方案，创建定时缓存</span></span>
<span class="line"><span></span></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="消息的id是自动随机生成的-还是业务唯一id" tabindex="-1"><a class="header-anchor" href="#消息的id是自动随机生成的-还是业务唯一id"><span>消息的id是自动随机生成的？还是业务唯一Id?</span></a></h2><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="shiki light-plus" style="background-color:#FFFFFF;color:#000000;" tabindex="0"><code><span class="line"><span>业务唯一id,通过业务标记bizTag生成业务唯一id</span></span>
<span class="line"><span></span></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="如何将一个正在运行的容器重新制作成镜像文件" tabindex="-1"><a class="header-anchor" href="#如何将一个正在运行的容器重新制作成镜像文件"><span>如何将一个正在运行的容器重新制作成镜像文件？</span></a></h2><blockquote><p>根据已有容器创建镜像文件</p></blockquote><ol><li>执行docker ps获取需要构建镜像的容器 ID 08cd43c7e50d。</li><li>执行docker pause 08cd43c7e50d暂停08cd43c7e50d容器的运行。</li><li>执行docker commit 08cd43c7e50d redis:test，基于容器 ID 08cd43c7e50d构建 Docker 镜像。</li><li>执行docker images redis:test，查看镜像是否成功构建。</li></ol><blockquote><p>dockerFile创建镜像文件</p></blockquote><div class="language-yaml line-numbers-mode" data-ext="yml" data-title="yml"><pre class="shiki light-plus" style="background-color:#FFFFFF;color:#000000;" tabindex="0"><code><span class="line"><span style="color:#800000;">dockerFile</span><span style="color:#000000;">:</span></span>
<span class="line"><span style="color:#0000FF;">FROM livingobjects/jre8</span></span>
<span class="line"><span style="color:#0000FF;">VOLUME /tmp</span></span>
<span class="line"><span style="color:#0000FF;">ENV TZ &quot;Asia/Shanghai&quot;</span></span>
<span class="line"><span style="color:#0000FF;">ADD ./build/libs/saascloud-opms-idg.jar app.jar</span></span>
<span class="line"><span style="color:#0000FF;">RUN bash -c &#39;touch /app.jar&#39;</span></span>
<span class="line"><span style="color:#0000FF;">CMD exec java $JVM_OPTS -Djava.security.egd=file:/dev/./urandom -jar /app.jar $JAVA_OPTS</span></span>
<span class="line"></span>
<span class="line"><span style="color:#0000FF;">docker build -f Dockerfile -t redis:test</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="什么时候走行级锁或表级锁" tabindex="-1"><a class="header-anchor" href="#什么时候走行级锁或表级锁"><span>什么时候走行级锁或表级锁</span></a></h2><p>行级锁，每次操作锁住对应的行数据。<strong>锁定粒度最小，发生锁冲突的概率最低，并发度最高</strong>。应用在InnoDB存储引擎中。 <strong>InnoDB的数据是基于索引组织的，行锁是通过对索引上的索引项加锁来实现的，而不是对记录加的锁</strong>。</p><p>如果字段加了索引，会对索引记录加锁，同时对应的行记录加锁</p><p>myisam引擎是对表加锁</p><p>默认情况下，InnoDB在 REPEATABLE READ事务隔离级别运行，InnoDB使用 next-key 锁进行搜索和索引扫描，以防止幻读。</p><ol><li><p>针对唯一索引进行检索时，对已存在的记录进行等值匹配时，将会自动优化为行锁。</p></li><li><p>InnoDB的行锁是针对于索引加的锁，不通过索引条件检索数据，那么InnoDB将对表中的所有记录加锁，此时 就会升级为表锁。</p></li></ol><h2 id="如何避免索引回查" tabindex="-1"><a class="header-anchor" href="#如何避免索引回查"><span>如何避免索引回查？</span></a></h2><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="shiki light-plus" style="background-color:#FFFFFF;color:#000000;" tabindex="0"><code><span class="line"><span>覆盖索引，要查询的信息就是对应索引以及id</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="为什么使用分库分表" tabindex="-1"><a class="header-anchor" href="#为什么使用分库分表"><span>为什么使用分库分表?</span></a></h2><blockquote><p>水平分库和水平分表</p></blockquote><p>为了解决单库单表的数量量太大，导致的查询效率问题，通过水平分库和分表将数据按照一定规则分散存储到不同库和不同表中，减少单表数据量，提高查询效率</p><p>一般单表达到500万进行分库分表</p><blockquote><p>缺点</p></blockquote><ul><li><p>分布式事务问题，即事务一致性问题</p></li><li><p>联表和嵌套查询问题</p></li><li><p>需要保证主键id全局唯一</p></li><li><p>运维量增加</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="shiki light-plus" style="background-color:#FFFFFF;color:#000000;" tabindex="0"><code><span class="line"><span>主要通过分库分表中间件，sql支持不足，跨库join时可能需将数据查询到中间件再join,导致效率问题</span></span>
<span class="line"><span></span></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li></ul><h2 id="新增es数据-查询不到的原因" tabindex="-1"><a class="header-anchor" href="#新增es数据-查询不到的原因"><span>新增es数据，查询不到的原因？</span></a></h2><ul><li>索引是否是环境自建</li><li>传参问题，构建索引名称出错</li><li>是否对索引进行刷新</li></ul><h2 id="rocketmq的替代方案" tabindex="-1"><a class="header-anchor" href="#rocketmq的替代方案"><span>rocketMq的替代方案？</span></a></h2><ul><li><p>使用线程池的方式</p></li><li><p>同步处理方式</p></li><li><p>使用其它消息队列如kafka</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="shiki light-plus" style="background-color:#FFFFFF;color:#000000;" tabindex="0"><code><span class="line"><span>分布式事务消息</span></span>
<span class="line"><span>严格保证消息有序</span></span>
<span class="line"><span>定时消息</span></span>
<span class="line"><span>消息失败重试</span></span>
<span class="line"><span></span></span>
<span class="line"><span>数据可靠性：</span></span>
<span class="line"><span>RocketMQ新增了同步刷盘机制，保证了可靠性；一个RocketMQ实例只有一个partition, 在replication时性能更好。</span></span>
<span class="line"><span></span></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><h2 id="异步更新库存" tabindex="-1"><a class="header-anchor" href="#异步更新库存"><span>异步更新库存？</span></a></h2><blockquote><p>起到解耦、异步、削峰的作用</p></blockquote><p>如果批量处理大量订单，使用同步更新方式，导致处理时间太长，对前端用户展示不友好</p><p>同时通过使用消息队列方式，实现解耦</p><blockquote><p>如何保证异步库存扣减数量不会出问题</p></blockquote><p>发送库存扣减消息时，会将同一仓库且同货主的库存变动任务发送到同一消息队列，并采用顺序消费的方式，保证库存更新的可靠性。</p><blockquote><p>租户，仓库和货主的关系</p></blockquote><p>前端vue中维护组件共享的变量，当切换仓库时，会重新刷新页面展示，每一个请求都会带有tenantId、warehouseId或customerId信息。</p>`,88),p=[l];function d(c,t){return n(),a("div",null,p)}const v=s(i,[["render",d],["__file","interview.html.vue"]]),u=JSON.parse('{"path":"/note/java/interview.html","title":"interview","lang":"zh-CN","frontmatter":{"description":"interview jvm监控 实际场景，设参，垃圾回收触发时机及条件 事务传播的具体场景 spring线程安全 递归算法题 hashtable与hashmap的区别 string、stringbuffer、stringbuilder 实现对象的克隆 gc？gc的作用 Spring支持的事务管理类型, 事务传播 什么是cookie ，cookie和se...","head":[["meta",{"property":"og:url","content":"https://wherywan.github.io/note/java/interview.html"}],["meta",{"property":"og:site_name","content":"HONG_JI"}],["meta",{"property":"og:title","content":"interview"}],["meta",{"property":"og:description","content":"interview jvm监控 实际场景，设参，垃圾回收触发时机及条件 事务传播的具体场景 spring线程安全 递归算法题 hashtable与hashmap的区别 string、stringbuffer、stringbuilder 实现对象的克隆 gc？gc的作用 Spring支持的事务管理类型, 事务传播 什么是cookie ，cookie和se..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2022-09-02T06:33:28.000Z"}],["meta",{"property":"article:author","content":"wanhongji"}],["meta",{"property":"article:modified_time","content":"2022-09-02T06:33:28.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"interview\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2022-09-02T06:33:28.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"wanhongji\\"}]}"]]},"headers":[{"level":2,"title":"jvm监控","slug":"jvm监控","link":"#jvm监控","children":[]},{"level":2,"title":"事务传播的具体场景","slug":"事务传播的具体场景","link":"#事务传播的具体场景","children":[]},{"level":2,"title":"spring线程安全","slug":"spring线程安全","link":"#spring线程安全","children":[]},{"level":2,"title":"递归算法题","slug":"递归算法题","link":"#递归算法题","children":[]},{"level":2,"title":"hashtable与hashmap的区别","slug":"hashtable与hashmap的区别","link":"#hashtable与hashmap的区别","children":[]},{"level":2,"title":"string、stringbuffer、stringbuilder","slug":"string、stringbuffer、stringbuilder","link":"#string、stringbuffer、stringbuilder","children":[]},{"level":2,"title":"实现对象的克隆","slug":"实现对象的克隆","link":"#实现对象的克隆","children":[]},{"level":2,"title":"gc？gc的作用","slug":"gc-gc的作用","link":"#gc-gc的作用","children":[]},{"level":2,"title":"Spring支持的事务管理类型, 事务传播","slug":"spring支持的事务管理类型-事务传播","link":"#spring支持的事务管理类型-事务传播","children":[]},{"level":2,"title":"什么是cookie ，cookie和session的区别","slug":"什么是cookie-cookie和session的区别","link":"#什么是cookie-cookie和session的区别","children":[]},{"level":2,"title":"什么情况下发生数据脏读","slug":"什么情况下发生数据脏读","link":"#什么情况下发生数据脏读","children":[]},{"level":2,"title":"accesslog","slug":"accesslog","link":"#accesslog","children":[]},{"level":2,"title":"生产环境索引失效，解决方案？","slug":"生产环境索引失效-解决方案","link":"#生产环境索引失效-解决方案","children":[]},{"level":2,"title":"如何按类型将数据映射到不同的类上？","slug":"如何按类型将数据映射到不同的类上","link":"#如何按类型将数据映射到不同的类上","children":[]},{"level":2,"title":"如果一个线程发生OOM，线程还会运行吗？会影响其他线程吗？","slug":"如果一个线程发生oom-线程还会运行吗-会影响其他线程吗","link":"#如果一个线程发生oom-线程还会运行吗-会影响其他线程吗","children":[]},{"level":2,"title":"如果主线程抛异常退出了，子线程还能运行么?","slug":"如果主线程抛异常退出了-子线程还能运行么","link":"#如果主线程抛异常退出了-子线程还能运行么","children":[]},{"level":2,"title":"如何在springboot启动时，加载资源到内存","slug":"如何在springboot启动时-加载资源到内存","link":"#如何在springboot启动时-加载资源到内存","children":[]},{"level":2,"title":"starter的意义","slug":"starter的意义","link":"#starter的意义","children":[]},{"level":2,"title":"分布式事务","slug":"分布式事务","link":"#分布式事务","children":[]},{"level":2,"title":"熔断降级如何处理?","slug":"熔断降级如何处理","link":"#熔断降级如何处理","children":[]},{"level":2,"title":"jvm参数设置？","slug":"jvm参数设置","link":"#jvm参数设置","children":[]},{"level":2,"title":"tomcat容器","slug":"tomcat容器","link":"#tomcat容器","children":[]},{"level":2,"title":"如何处理缓存穿透、雪崩、击穿等问题的？","slug":"如何处理缓存穿透、雪崩、击穿等问题的","link":"#如何处理缓存穿透、雪崩、击穿等问题的","children":[]},{"level":2,"title":"消息的id是自动随机生成的？还是业务唯一Id?","slug":"消息的id是自动随机生成的-还是业务唯一id","link":"#消息的id是自动随机生成的-还是业务唯一id","children":[]},{"level":2,"title":"如何将一个正在运行的容器重新制作成镜像文件？","slug":"如何将一个正在运行的容器重新制作成镜像文件","link":"#如何将一个正在运行的容器重新制作成镜像文件","children":[]},{"level":2,"title":"什么时候走行级锁或表级锁","slug":"什么时候走行级锁或表级锁","link":"#什么时候走行级锁或表级锁","children":[]},{"level":2,"title":"如何避免索引回查？","slug":"如何避免索引回查","link":"#如何避免索引回查","children":[]},{"level":2,"title":"为什么使用分库分表?","slug":"为什么使用分库分表","link":"#为什么使用分库分表","children":[]},{"level":2,"title":"新增es数据，查询不到的原因？","slug":"新增es数据-查询不到的原因","link":"#新增es数据-查询不到的原因","children":[]},{"level":2,"title":"rocketMq的替代方案？","slug":"rocketmq的替代方案","link":"#rocketmq的替代方案","children":[]},{"level":2,"title":"异步更新库存？","slug":"异步更新库存","link":"#异步更新库存","children":[]}],"git":{"createdTime":1655634857000,"updatedTime":1662100408000,"contributors":[{"name":"wanhongji","email":"wherywan@163.com","commits":3},{"name":"wanhongji","email":"wan_hongji@163.com","commits":1}]},"readingTime":{"minutes":11.97,"words":3592},"filePathRelative":"note/java/interview.md","localizedDate":"2022年6月19日","excerpt":"\\n<h2>jvm监控</h2>\\n<p>实际场景，设参，垃圾回收触发时机及条件</p>\\n<h2>事务传播的具体场景</h2>\\n<h2>spring线程安全</h2>\\n<h2>递归算法题</h2>\\n<h2>hashtable与hashmap的区别</h2>\\n<div class=\\"language-text line-numbers-mode\\" data-ext=\\"text\\" data-title=\\"text\\"><pre class=\\"shiki light-plus\\" style=\\"background-color:#FFFFFF;color:#000000\\" tabindex=\\"0\\"><code><span class=\\"line\\"><span>hashtable是一个线程安全的类，用于存放键值对。内部的方法都被synchronized修饰</span></span>\\n<span class=\\"line\\"><span>hashmap与之相反，键和值可以为null, hashtable不可以用null作为键</span></span>\\n<span class=\\"line\\"><span>HashMap的初始容量为16，Hashtable初始容量为11，两者的填充因子默认都是0.75。</span></span>\\n<span class=\\"line\\"><span>hashmap的扩容是2的n次方，hashtable是2倍加1</span></span>\\n<span class=\\"line\\"><span>使用2的n次方便于使用与运算得到对应的数组散列值或索引</span></span>\\n<span class=\\"line\\"><span>在多线程环境下若使用HashMap需要使用Collections.synchronizedMap()方法来获取一个线程安全的集合</span></span>\\n<span class=\\"line\\"><span></span></span></code></pre><div class=\\"line-numbers\\" aria-hidden=\\"true\\"><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div></div></div>","autoDesc":true}');export{v as comp,u as data};
