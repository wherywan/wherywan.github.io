import{_ as o}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as t,o as d,c as p,a as e,b as a,d as s,e as n}from"./app-hoN0JGLf.js";const i={},c=e("h1",{id:"k8s",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#k8s"},[e("span",null,"k8s")])],-1),r=e("p",null,"它是生产级别的容器编排系统",-1),h=e("blockquote",null,[e("p",null,"资源")],-1),u=e("ul",null,[e("li",null,"master"),e("li",null,"nodes")],-1),b=e("h2",{id:"k8s搭建",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#k8s搭建"},[e("span",null,"k8s搭建")])],-1),k={href:"https://blog.csdn.net/qq_40954652/article/details/123208590",target:"_blank",rel:"noopener noreferrer"},m=n(`<h3 id="常用命令" tabindex="-1"><a class="header-anchor" href="#常用命令"><span>常用命令</span></a></h3><p>以下是一些常用的Kubernetes（k8s）命令：</p><ol><li><code>kubectl get pods</code>：获取当前命名空间下的所有Pod。</li><li><code>kubectl get deployments</code>：获取当前命名空间下的所有部署。</li><li><code>kubectl get services</code>：获取当前命名空间下的所有服务。</li><li><code>kubectl get nodes</code>：获取集群中的所有节点。</li><li><code>kubectl describe pod &lt;pod-name&gt;</code>：获取有关特定Pod的详细信息。</li><li><code>kubectl describe deployment &lt;deployment-name&gt;</code>：获取有关特定部署的详细信息。</li><li><code>kubectl describe service &lt;service-name&gt;</code>：获取有关特定服务的详细信息。</li><li><code>kubectl logs &lt;pod-name&gt;</code>：查看特定Pod的日志。</li><li><code>kubectl exec -it &lt;pod-name&gt; -- &lt;command&gt;</code>：在特定Pod中执行命令。</li><li><code>kubectl create -f &lt;filename&gt;</code>：使用YAML或JSON文件创建资源。</li><li><code>kubectl apply -f &lt;filename&gt;</code>：使用YAML或JSON文件创建或更新资源。</li><li><code>kubectl delete pod &lt;pod-name&gt;</code>：删除特定的Pod。</li><li><code>kubectl delete deployment &lt;deployment-name&gt;</code>：删除特定的部署。</li><li><code>kubectl delete service &lt;service-name&gt;</code>：删除特定的服务。</li><li><code>kubectl scale deployment &lt;deployment-name&gt; --replicas=&lt;replica-count&gt;</code>：调整部署的副本数。</li></ol><p>可以通过运行<code>kubectl --help</code>命令来查看所有可用的kubectl命令及其选项。</p><h3 id="命名空间" tabindex="-1"><a class="header-anchor" href="#命名空间"><span>命名空间</span></a></h3><p>Kubernetes中的命名空间（Namespace）是用于对集群资源进行逻辑隔离和组织的一种机制。它允许将集群内的资源划分为多个独立的虚拟集群，每个命名空间都有自己的一组资源。</p><h3 id="pod" tabindex="-1"><a class="header-anchor" href="#pod"><span>pod</span></a></h3><p>在Kubernetes（简称为K8s）中，Pod是最小的可调度和可部署的单元。它是Kubernetes中运行和管理容器化应用程序的基本对象。</p><p>Pod可以看作是一个或多个相关容器的组合，它们共享相同的网络命名空间、存储卷和其他资源。这些容器在Pod中运行在同一个节点上，并且它们可以相互之间通过本地的网络进行通信。</p><p>以下是一些关于Pod的要点：</p><ol><li><p>容器组合：Pod可以包含一个或多个容器。这些容器通常是相互关联、相互协作的应用程序组件，它们共享相同的生命周期和资源。</p></li><li><p>共享命名空间：Pod中的所有容器共享相同的网络命名空间。它们可以通过<code>localhost</code>相互通信，使用<code>localhost:port</code>进行服务之间的通信。</p></li><li><p>共享存储卷：Pod中的容器可以挂载共享的存储卷。这样，它们可以共享文件和数据，实现数据的持久化和共享。</p></li><li><p>生命周期和调度：Pod作为一个整体具有生命周期，它可以被创建、启动、停止和销毁。Pod通过调度器（Scheduler）被分配到集群中的某个节点上运行。</p></li><li><p>稳定的网络标识：每个Pod都有一个唯一的IP地址，用于在集群内部进行通信。这个IP地址与Pod的生命周期绑定，可以确保Pod中的容器能够可靠地被其他容器或服务访问。</p></li><li><p>灵活性和弹性：Pod是可扩展的，可以根据需要进行水平伸缩。通过复制Pod，可以创建多个相同配置的副本，并使它们在集群中的不同节点上运行，以增加应用程序的可用性和负载均衡能力。</p></li></ol><p>Pod是Kubernetes中的核心概念，它提供了一个逻辑上相关的容器组合，并为这些容器共享资源和环境。通过Pod，Kubernetes实现了对容器化应用程序的高效调度、资源管理和服务发现。</p><h3 id="pod工作原理" tabindex="-1"><a class="header-anchor" href="#pod工作原理"><span>pod工作原理</span></a></h3><p>在Kubernetes中，Master节点并不直接发送命令给Nodes节点来创建Pod中的容器。实际上，Master节点负责整体的集群管理和控制，而Nodes节点承担实际的容器创建和管理任务。</p><p>下面是Pod的创建和管理的基本流程：</p><p>用户通过Kubernetes API或命令行工具向Master节点提交Pod的描述文件（通常是YAML或JSON格式）。</p><p>Master节点的API Server接收到用户提交的Pod描述后，会进行验证和处理。如果描述文件合法，API Server将存储Pod的描述信息到etcd中的集群配置存储中。</p><p>Scheduler组件（运行在Master节点上）负责根据集群的资源情况、调度策略等因素，决定将Pod调度到哪个Nodes节点上运行。Scheduler会将Pod绑定到一个合适的Nodes节点。</p><p>Kubelet组件（运行在每个Nodes节点上）定期向Master节点的API Server汇报节点的状态和可用资源情况。</p><p>Kubelet在接收到来自Master节点的调度指令后，会根据指令在本地节点上创建并运行Pod中的容器。Kubelet会与容器运行时（如Docker、containerd等）进行交互，实际创建和管理容器。</p><p>一旦Pod中的容器成功创建并运行，Kubelet会将容器的状态信息反馈给Master节点，Master节点会更新集群状态和监控信息。</p><p>总结起来，Master节点通过Scheduler将Pod调度到适合的Nodes节点，而Nodes节点上的Kubelet负责具体的容器创建和管理。这种分工协作的方式确保了Pod在集群中的正确创建和运行。</p><h3 id="pod可以理解为一个配置文件吗" tabindex="-1"><a class="header-anchor" href="#pod可以理解为一个配置文件吗"><span>pod可以理解为一个配置文件吗？</span></a></h3><p>Pod在Kubernetes中不是一个配置文件，而是一个运行和管理容器化应用程序的基本单位。Pod可以通过配置文件（通常使用YAML或JSON格式）来定义其规范和属性，但Pod本身不是一个配置文件。</p><p>配置文件包含Pod的描述信息，例如容器镜像、资源需求、环境变量、存储卷挂载等。这些配置文件可以通过Kubernetes API服务器进行创建、更新和删除操作，从而实现对Pod的管理和控制。</p><h3 id="pod与docker-compose" tabindex="-1"><a class="header-anchor" href="#pod与docker-compose"><span>pod与docker-compose</span></a></h3><p>Pod更适用于分布式环境中的容器编排和管理，而Docker Compose更适用于单个主机上的容器编排和管理。</p><p>Pod具有更丰富的功能和可扩展性，适用于在大规模集群中管理容器化应用程序。</p><h3 id="pod的ip与容器内部ip" tabindex="-1"><a class="header-anchor" href="#pod的ip与容器内部ip"><span>pod的ip与容器内部ip</span></a></h3><h3 id="同一个-pod-中的所有容器-ip-地址都相同" tabindex="-1"><a class="header-anchor" href="#同一个-pod-中的所有容器-ip-地址都相同"><span>同一个 Pod 中的所有容器 IP 地址都相同？</span></a></h3><h3 id="容器组和控制器" tabindex="-1"><a class="header-anchor" href="#容器组和控制器"><span>容器组和控制器</span></a></h3><p>用户应该始终使用控制器来创建 Pod，而不是直接创建 Pod，控制器可以提供如下特性：</p><ul><li><p>水平扩展（运行 Pod 的多个副本）</p></li><li><p>rollout（版本更新）</p></li><li><p>self-healing（故障恢复）</p></li></ul><p>例如：当一个节点出现故障，控制器可以自动地在另一个节点调度一个配置完全一样的 Pod，以替换故障节点上的 Pod。</p><p>在 Kubernetes 中，广泛使用的控制器有：</p><ul><li>Deployment</li><li>StatefulSet</li><li>DaemonSet 控制器通过其中配置的 Pod Template 信息来创建 Pod。</li></ul><h3 id="pod容器" tabindex="-1"><a class="header-anchor" href="#pod容器"><span>pod容器</span></a></h3><p>在Kubernetes中，Pod中的容器的/etc/hosts文件通常会包含Pod的IP地址和Pod名称的映射关系。</p><p>当容器运行在Pod中时，Kubernetes会自动在每个容器的/etc/hosts文件中添加一条记录，将Pod的IP地址映射到Pod的名称。这使得容器可以通过Pod的名称来解析和访问其他容器或服务</p><h3 id="网络命名空间与虚拟网络设备对veth-pair" tabindex="-1"><a class="header-anchor" href="#网络命名空间与虚拟网络设备对veth-pair"><span>网络命名空间与虚拟网络设备对veth pair</span></a></h3><p>veth-pair 主要用于不同命名空间的通信</p><h3 id="pod中容器共享pause容器的网络命名空间和虚拟网络设备veth-pair" tabindex="-1"><a class="header-anchor" href="#pod中容器共享pause容器的网络命名空间和虚拟网络设备veth-pair"><span>pod中容器共享pause容器的网络命名空间和虚拟网络设备veth pair?</span></a></h3><p>在 Kubernetes 中，Pod 是最小的可调度单元，通常由一个或多个容器组成。每个 Pod 都有自己的网络命名空间，这意味着每个 Pod 内的容器都有自己的网络栈，IP 地址和网络设备</p><p>为了实现 Pod 内容器之间的网络通信，Kubernetes 使用了一个特殊的容器，称为 Pause 容器（也称为 Infra 容器）。</p><p>Pause 容器是 Pod 中的第一个容器，它负责创建 Pod 的网络命名空间和虚拟网络设备。其他容器在启动时会共享该网络命名空间和虚拟网络设备。</p><p>这种共享的方式是通过共享 Linux 系统的网络命名空间和虚拟网络设备（veth pair）实现的。</p><p>具体来说，当一个 Pod 创建时，Kubernetes 会为该 Pod 创建一个网络命名空间，并在该命名空间中创建一个 Pause 容器。</p><p>Pause 容器会分配一个虚拟网络设备（veth pair），其中一个端点连接到 Pause 容器内部，另一个端点连接到宿主机的网络命名空间中。</p><p>随后，其他容器将会在同一网络命名空间中启动，并共享 Pause 容器创建的网络命名空间和虚拟网络设备。这意味着这些容器可以通过共享的网络命名空间和虚拟网络设备进行通信，</p><p>它们具有相同的网络视图和相同的 IP 地址空间。</p><p>这种设计使得 Pod 内的容器可以像在同一主机上运行的进程一样进行网络通信，而无需通过网络协议栈的封装和解封装来实现。</p><p>这种共享网络命名空间和虚拟网络设备的机制使得容器之间的网络通信更加高效和快速。</p><h3 id="service配置" tabindex="-1"><a class="header-anchor" href="#service配置"><span>service配置</span></a></h3><p>在Kubernetes中，Service是用于公开和暴露应用程序的网络服务的抽象。<code>ports</code>字段是Service对象中用于定义要公开的端口和与之相关的配置的部分。下面是对<code>ports</code>字段配置的解释：</p><div class="language-yaml line-numbers-mode" data-ext="yml" data-title="yml"><pre class="shiki light-plus" style="background-color:#FFFFFF;color:#000000;" tabindex="0"><code><span class="line"><span style="color:#800000;">ports</span><span style="color:#000000;">:</span></span>
<span class="line"><span style="color:#000000;">- </span><span style="color:#800000;">name</span><span style="color:#000000;">: </span><span style="color:#0000FF;">http</span></span>
<span class="line"><span style="color:#800000;">  protocol</span><span style="color:#000000;">: </span><span style="color:#0000FF;">TCP</span></span>
<span class="line"><span style="color:#800000;">  port</span><span style="color:#000000;">: </span><span style="color:#098658;">80</span></span>
<span class="line"><span style="color:#800000;">  targetPort</span><span style="color:#000000;">: </span><span style="color:#098658;">8080</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p><code>name</code>（可选）：为端口指定一个可读性强的名称，用于标识该端口的用途。这个字段是可选的，但推荐使用，特别是在有多个端口的情况下，可以更好地理解和维护Service配置。</p></li><li><p><code>protocol</code>（可选）：指定端口使用的协议，可以是TCP或UDP。如果不指定，默认为TCP。根据应用程序的需要，可以选择合适的协议类型。</p></li><li><p><code>port</code>：指定Service将公开的端口号。这是其他服务或客户端用于与Service通信的端口。在上述示例中，Service将公开端口号为80，以便其他组件可以通过该端口与Service进行通信。</p></li><li><p><code>targetPort</code>：指定将流量转发到的Pod中容器的端口号。这是Service将请求转发给后端Pod的目标端口。在上述示例中，流量将转发到Pod中容器的端口号8080。</p></li></ul><p><code>ports</code>字段可以包含多个端口定义，使得一个Service可以公开多个端口，以便处理不同类型的流量或服务。</p><p>需要注意的是，Service配置的<code>ports</code>字段只是定义了Service的端口映射规则，实际上需要通过使用Kubernetes提供的网络插件来实现流量的转发和负载均衡。这样，其他组件和客户端可以通过Service的IP地址和端口来访问后端Pod中运行的应用程序。</p><p>希望这个解释对你有所帮助！</p><h2 id="kuboard" tabindex="-1"><a class="header-anchor" href="#kuboard"><span>kuboard</span></a></h2><h2 id="kuber-operator" tabindex="-1"><a class="header-anchor" href="#kuber-operator"><span>kuber operator</span></a></h2><ul><li>custom resource crd文件</li><li>控制循环</li></ul><h2 id="通信" tabindex="-1"><a class="header-anchor" href="#通信"><span>通信</span></a></h2><ul><li>iptables(NAT地址转换)</li><li>pod中容器使用同一网络命名空间，可使用localhost进行通信</li></ul>`,64);function P(g,v){const l=t("ExternalLinkIcon");return d(),p("div",null,[c,r,h,u,b,e("p",null,[e("a",k,[a("搭建"),s(l)])]),m])}const _=o(i,[["render",P],["__file","k8s.html.vue"]]),x=JSON.parse('{"path":"/note/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%8E%AF%E5%A2%83/k8s.html","title":"k8s","lang":"zh-CN","frontmatter":{"description":"k8s 它是生产级别的容器编排系统 资源 master nodes k8s搭建 搭建 常用命令 以下是一些常用的Kubernetes（k8s）命令： kubectl get pods：获取当前命名空间下的所有Pod。 kubectl get deployments：获取当前命名空间下的所有部署。 kubectl get services：获取当前命名空...","head":[["meta",{"property":"og:url","content":"https://wherywan.github.io/note/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%8E%AF%E5%A2%83/k8s.html"}],["meta",{"property":"og:site_name","content":"HONG_JI"}],["meta",{"property":"og:title","content":"k8s"}],["meta",{"property":"og:description","content":"k8s 它是生产级别的容器编排系统 资源 master nodes k8s搭建 搭建 常用命令 以下是一些常用的Kubernetes（k8s）命令： kubectl get pods：获取当前命名空间下的所有Pod。 kubectl get deployments：获取当前命名空间下的所有部署。 kubectl get services：获取当前命名空..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-11-01T09:29:34.000Z"}],["meta",{"property":"article:author","content":"wanhongji"}],["meta",{"property":"article:modified_time","content":"2023-11-01T09:29:34.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"k8s\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2023-11-01T09:29:34.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"wanhongji\\"}]}"]]},"headers":[{"level":2,"title":"k8s搭建","slug":"k8s搭建","link":"#k8s搭建","children":[{"level":3,"title":"常用命令","slug":"常用命令","link":"#常用命令","children":[]},{"level":3,"title":"命名空间","slug":"命名空间","link":"#命名空间","children":[]},{"level":3,"title":"pod","slug":"pod","link":"#pod","children":[]},{"level":3,"title":"pod工作原理","slug":"pod工作原理","link":"#pod工作原理","children":[]},{"level":3,"title":"pod可以理解为一个配置文件吗？","slug":"pod可以理解为一个配置文件吗","link":"#pod可以理解为一个配置文件吗","children":[]},{"level":3,"title":"pod与docker-compose","slug":"pod与docker-compose","link":"#pod与docker-compose","children":[]},{"level":3,"title":"pod的ip与容器内部ip","slug":"pod的ip与容器内部ip","link":"#pod的ip与容器内部ip","children":[]},{"level":3,"title":"同一个 Pod 中的所有容器 IP 地址都相同？","slug":"同一个-pod-中的所有容器-ip-地址都相同","link":"#同一个-pod-中的所有容器-ip-地址都相同","children":[]},{"level":3,"title":"容器组和控制器","slug":"容器组和控制器","link":"#容器组和控制器","children":[]},{"level":3,"title":"pod容器","slug":"pod容器","link":"#pod容器","children":[]},{"level":3,"title":"网络命名空间与虚拟网络设备对veth pair","slug":"网络命名空间与虚拟网络设备对veth-pair","link":"#网络命名空间与虚拟网络设备对veth-pair","children":[]},{"level":3,"title":"pod中容器共享pause容器的网络命名空间和虚拟网络设备veth pair?","slug":"pod中容器共享pause容器的网络命名空间和虚拟网络设备veth-pair","link":"#pod中容器共享pause容器的网络命名空间和虚拟网络设备veth-pair","children":[]},{"level":3,"title":"service配置","slug":"service配置","link":"#service配置","children":[]}]},{"level":2,"title":"kuboard","slug":"kuboard","link":"#kuboard","children":[]},{"level":2,"title":"kuber operator","slug":"kuber-operator","link":"#kuber-operator","children":[]},{"level":2,"title":"通信","slug":"通信","link":"#通信","children":[]}],"git":{"createdTime":1667383621000,"updatedTime":1698830974000,"contributors":[{"name":"wanhongji","email":"wherywan@163.com","commits":5}]},"readingTime":{"minutes":9.62,"words":2886},"filePathRelative":"note/服务器环境/k8s.md","localizedDate":"2022年11月2日","excerpt":"\\n<p>它是生产级别的容器编排系统</p>\\n<blockquote>\\n<p>资源</p>\\n</blockquote>\\n<ul>\\n<li>master</li>\\n<li>nodes</li>\\n</ul>\\n<h2>k8s搭建</h2>\\n<p><a href=\\"https://blog.csdn.net/qq_40954652/article/details/123208590\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">搭建</a></p>\\n<h3>常用命令</h3>\\n<p>以下是一些常用的Kubernetes（k8s）命令：</p>\\n<ol>\\n<li><code>kubectl get pods</code>：获取当前命名空间下的所有Pod。</li>\\n<li><code>kubectl get deployments</code>：获取当前命名空间下的所有部署。</li>\\n<li><code>kubectl get services</code>：获取当前命名空间下的所有服务。</li>\\n<li><code>kubectl get nodes</code>：获取集群中的所有节点。</li>\\n<li><code>kubectl describe pod &lt;pod-name&gt;</code>：获取有关特定Pod的详细信息。</li>\\n<li><code>kubectl describe deployment &lt;deployment-name&gt;</code>：获取有关特定部署的详细信息。</li>\\n<li><code>kubectl describe service &lt;service-name&gt;</code>：获取有关特定服务的详细信息。</li>\\n<li><code>kubectl logs &lt;pod-name&gt;</code>：查看特定Pod的日志。</li>\\n<li><code>kubectl exec -it &lt;pod-name&gt; -- &lt;command&gt;</code>：在特定Pod中执行命令。</li>\\n<li><code>kubectl create -f &lt;filename&gt;</code>：使用YAML或JSON文件创建资源。</li>\\n<li><code>kubectl apply -f &lt;filename&gt;</code>：使用YAML或JSON文件创建或更新资源。</li>\\n<li><code>kubectl delete pod &lt;pod-name&gt;</code>：删除特定的Pod。</li>\\n<li><code>kubectl delete deployment &lt;deployment-name&gt;</code>：删除特定的部署。</li>\\n<li><code>kubectl delete service &lt;service-name&gt;</code>：删除特定的服务。</li>\\n<li><code>kubectl scale deployment &lt;deployment-name&gt; --replicas=&lt;replica-count&gt;</code>：调整部署的副本数。</li>\\n</ol>","autoDesc":true}');export{_ as comp,x as data};
