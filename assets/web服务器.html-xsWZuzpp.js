import{_ as a}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as l,o as r,c as i,a as e,b as o,d as n,e as s}from"./app-hoN0JGLf.js";const c={},p=e("h1",{id:"web服务器",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#web服务器"},[e("span",null,"web服务器")])],-1),d=e("h2",{id:"tomcat",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#tomcat"},[e("span",null,"tomcat")])],-1),h={href:"https://www.likecs.com/show-305337039.html",target:"_blank",rel:"noopener noreferrer"},b={href:"https://mp.weixin.qq.com/s?__biz=MzA5ODA0NDE2MA==&mid=2649774376&idx=1&sn=5273159548ea223775dd3d14528e8f3a&chksm=88936947bfe4e0517c1d025d4f3fff754a5e4b907dba94a0189e4591d90dbd672d7c32a92896&scene=27",target:"_blank",rel:"noopener noreferrer"},u=s('<ul><li>web服务器，实现了对 Java Servlet 和 JSP（JavaServer Pages）技术的支持</li><li>前身是catalina servlet 容器，用于运行servlet程序</li></ul><h3 id="applicationcontext与standardcontext" tabindex="-1"><a class="header-anchor" href="#applicationcontext与standardcontext"><span>ApplicationContext与StandardContext</span></a></h3><ul><li>职责不同</li><li>StandardContext掌握控制权，也是一个容器，负责servlet的选择，session cookie 的管理</li><li>ApplicationContext是servlet运行环境的上下文信息</li></ul><h3 id="standardcontext" tabindex="-1"><a class="header-anchor" href="#standardcontext"><span>StandardContext</span></a></h3><p>负责servlet的选择，session cookie 的管理</p><ul><li>getServletContext 获取ServletContext</li></ul><h3 id="applicationcontext" tabindex="-1"><a class="header-anchor" href="#applicationcontext"><span>ApplicationContext</span></a></h3><h3 id="从组件角度" tabindex="-1"><a class="header-anchor" href="#从组件角度"><span>从组件角度</span></a></h3><blockquote><p>server</p></blockquote><p>服务器顶层，可以包含多个service</p><blockquote><p>service</p></blockquote><ul><li>一个service只有一个engine</li><li>可以有多个connector处理不同协议的请求</li></ul><blockquote><p>connector</p></blockquote><ol><li>支持多种协议</li><li>连接容器和service</li><li>封装request和response</li><li>对请求的封装使用了包装器RequestFacade</li><li>交给servlet后还会对请求包装ServletRequestWrapper、HttpServletRequestWrapper</li></ol><blockquote><p>container 引擎(Engine)、主机(Host)、上下文(Context)和Wraper均继承自Container接口，所以它们都是容器。</p></blockquote><ul><li>engine 可配置多个host，一个ip对应多个域名，以域名划分host容器</li><li>host host可配置多个context，有默认host,即webapps目录</li><li>context 这里的上下文即standardContext(standardContext实现context接口)属于host,即一个web应用，默认root文件夹，可配置其他文件夹</li><li>wrapper 封装着一个servlet</li></ul><blockquote><p>service内部组件</p></blockquote><ul><li>Manager servletContext中的组件，管理session会话</li><li>logger 日志</li><li>context 加载器，和类加载有关，只会开放给Context所使用</li><li>pipeline 管道组件，配合Valve实现过滤器功能</li><li>value 阀门组件，配合Pipeline实现过滤器功能</li></ul><h3 id="从一个完整请求的角度来看" tabindex="-1"><a class="header-anchor" href="#从一个完整请求的角度来看"><span>从一个完整请求的角度来看</span></a></h3><p>假设来自客户的请求为：http://localhost:8080/test/index.jsp 请求被发送到本机端口8080，被在那里侦听的Coyote HTTP/1.1 Connector,然后</p><ul><li>Connector把该请求交给它所在的Service的Engine来处理，并等待Engine的回应</li><li>Engine获得请求localhost:8080/test/index.jsp，匹配它所有虚拟主机Host</li><li>Engine匹配到名为localhost的Host(即使匹配不到也把请求交给该Host处理，因为该Host被定义为该Engine的默认主机) localhost</li><li>Host获得请求/test/index.jsp，匹配它所拥有的所有Context</li><li>Host匹配到路径为/test的Context(如果匹配不到就把该请求交给路径名为&quot;&quot;的Context去处理)</li><li>path=&quot;/test&quot;的Context获得请求/index.jsp，在它的mapping table中寻找对应的servlet</li><li>Context匹配到URL PATTERN为*.jsp的servlet，对应于JspServlet类，构造HttpServletRequest对象和HttpServletResponse对象，作为参数调用JspServlet的doGet或doPost方法</li><li>Context把执行完了之后的HttpServletResponse对象返回给Host</li><li>Host把HttpServletResponse对象返回给Engine</li><li>Engine把HttpServletResponse对象返回给Connector</li><li>Connector把HttpServletResponse对象返回给客户browse</li></ul><h3 id="从后续深入理解的角度" tabindex="-1"><a class="header-anchor" href="#从后续深入理解的角度"><span>从后续深入理解的角度</span></a></h3><ul><li>基于组件的架构</li><li>基于生命周期<br> 各个组件的源代码，会发现绝大多数组件实现了Lifecycle接口，这也就是我们所说的基于生命周期。生命周期的各个阶段的触发又是基于事件的方式。</li><li>基于JMX</li></ul><h3 id="servlet引擎-容器" tabindex="-1"><a class="header-anchor" href="#servlet引擎-容器"><span>servlet引擎(容器)</span></a></h3><p>Servlet没有main方法，所以，如果要执行，则需要在一个容器里面才能执行，这个容器就是为了支持Servlet的功能而存在</p><h3 id="jsp引擎" tabindex="-1"><a class="header-anchor" href="#jsp引擎"><span>jsp引擎</span></a></h3><p>将jsp转为servlet，代码动态构建网页输出</p><h3 id="线程模型" tabindex="-1"><a class="header-anchor" href="#线程模型"><span>线程模型</span></a></h3><ul><li>acceptor</li><li>poller</li><li>worker线程池</li></ul><h3 id="org-apache-coyote-response" tabindex="-1"><a class="header-anchor" href="#org-apache-coyote-response"><span>org.apache.coyote.Response</span></a></h3><h3 id="nioendpoint-nio2endpoint-abstractendpoint" tabindex="-1"><a class="header-anchor" href="#nioendpoint-nio2endpoint-abstractendpoint"><span>NioEndpoint,Nio2Endpoint,AbstractEndpoint</span></a></h3><ul><li>createSocketProcessor</li><li>processSocket 创建线程任务SocketProcessor交给线程池执行</li></ul><h3 id="nioacceptor-nioendpoint下的accept任务" tabindex="-1"><a class="header-anchor" href="#nioacceptor-nioendpoint下的accept任务"><span>NioAcceptor，NioEndpoint下的accept任务</span></a></h3><ul><li>run</li></ul><h3 id="socketprocessor-nioendpoint下的内部类" tabindex="-1"><a class="header-anchor" href="#socketprocessor-nioendpoint下的内部类"><span>SocketProcessor，NioEndpoint下的内部类</span></a></h3><ul><li>doRun</li></ul><h3 id="connector" tabindex="-1"><a class="header-anchor" href="#connector"><span>Connector</span></a></h3><ul><li>实例时创建ProtocolHandler的实现Http11NioProtocol</li><li>initInternal，初始化CoyoteAdapter，并塞到ProtocolHandler中</li></ul><h3 id="http11nioprotocol-http11nio2protocol-abstracthttp11jsseprotocol-abstracthttp11protocol-abstractprotocol" tabindex="-1"><a class="header-anchor" href="#http11nioprotocol-http11nio2protocol-abstracthttp11jsseprotocol-abstracthttp11protocol-abstractprotocol"><span>Http11NioProtocol,Http11Nio2Protocol,AbstractHttp11JsseProtocol,AbstractHttp11Protocol,AbstractProtocol</span></a></h3><p>实例化Http11NioProtocol，同时创建NioEndpoint，ConnectionHandler</p><h4 id="connectionhandler-abstractprotocol下的内部类" tabindex="-1"><a class="header-anchor" href="#connectionhandler-abstractprotocol下的内部类"><span>ConnectionHandler，AbstractProtocol下的内部类</span></a></h4><ul><li>process 创建Http11Processor处理socketWrapper,socket</li></ul><h3 id="http11processor-abstractprocessorlight-processor" tabindex="-1"><a class="header-anchor" href="#http11processor-abstractprocessorlight-processor"><span>Http11Processor,AbstractProcessorLight,Processor</span></a></h3><ul><li>process</li><li>service</li><li>action</li></ul><h3 id="coyoteadapter" tabindex="-1"><a class="header-anchor" href="#coyoteadapter"><span>CoyoteAdapter</span></a></h3><p>创建ServletRequest,ServletResponse,并设置 org.apache.coyote.Request req, org.apache.coyote.Response res,主要用于数据的交互</p><h3 id="lifecyclebase" tabindex="-1"><a class="header-anchor" href="#lifecyclebase"><span>LifecycleBase</span></a></h3><ul><li>StandardServer, 包含service</li><li>StandardService,包含connector</li></ul><h3 id="container" tabindex="-1"><a class="header-anchor" href="#container"><span>Container</span></a></h3><ul><li>StandardEngine</li><li>StandardHost</li><li>StandardContext</li><li>StandardWrapper <ul><li>ApplicationDispatcher</li></ul></li><li>pipeline <ul><li>base</li></ul></li></ul><h3 id="servlet3-0-异步请求" tabindex="-1"><a class="header-anchor" href="#servlet3-0-异步请求"><span>servlet3.0 异步请求</span></a></h3><ul><li>HttpServletRequest的startAsync启动异步处理，释放容器worker线程</li><li>AsyncContextImpl,AsyncContext <ul><li>setStarted</li><li>AsyncRunnable 设置请求状态为DISPATCHED</li></ul></li></ul><h4 id="asyncstatemachine" tabindex="-1"><a class="header-anchor" href="#asyncstatemachine"><span>AsyncStateMachine</span></a></h4><ul><li>DISPATCHED 非异步状态</li><li>STARTING</li><li>STARTED</li><li>DISPATCHING</li></ul><h2 id="jetty" tabindex="-1"><a class="header-anchor" href="#jetty"><span>jetty</span></a></h2><h2 id="undertow" tabindex="-1"><a class="header-anchor" href="#undertow"><span>undertow</span></a></h2>',56);function v(x,g){const t=l("ExternalLinkIcon");return r(),i("div",null,[p,d,e("p",null,[e("a",h,[o("参考"),n(t)])]),e("p",null,[e("a",b,[o("参考"),n(t)])]),u])}const k=a(c,[["render",v],["__file","web服务器.html.vue"]]),S=JSON.parse('{"path":"/note/web/web%E6%9C%8D%E5%8A%A1%E5%99%A8.html","title":"web服务器","lang":"zh-CN","frontmatter":{"category":["web"],"description":"web服务器 tomcat 参考 参考 web服务器，实现了对 Java Servlet 和 JSP（JavaServer Pages）技术的支持 前身是catalina servlet 容器，用于运行servlet程序 ApplicationContext与StandardContext 职责不同 StandardContext掌握控制权，也是一个容...","head":[["meta",{"property":"og:url","content":"https://wherywan.github.io/note/web/web%E6%9C%8D%E5%8A%A1%E5%99%A8.html"}],["meta",{"property":"og:site_name","content":"HONG_JI"}],["meta",{"property":"og:title","content":"web服务器"}],["meta",{"property":"og:description","content":"web服务器 tomcat 参考 参考 web服务器，实现了对 Java Servlet 和 JSP（JavaServer Pages）技术的支持 前身是catalina servlet 容器，用于运行servlet程序 ApplicationContext与StandardContext 职责不同 StandardContext掌握控制权，也是一个容..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-09-08T03:26:07.000Z"}],["meta",{"property":"article:author","content":"wanhongji"}],["meta",{"property":"article:modified_time","content":"2023-09-08T03:26:07.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"web服务器\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2023-09-08T03:26:07.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"wanhongji\\"}]}"]]},"headers":[{"level":2,"title":"tomcat","slug":"tomcat","link":"#tomcat","children":[{"level":3,"title":"ApplicationContext与StandardContext","slug":"applicationcontext与standardcontext","link":"#applicationcontext与standardcontext","children":[]},{"level":3,"title":"StandardContext","slug":"standardcontext","link":"#standardcontext","children":[]},{"level":3,"title":"ApplicationContext","slug":"applicationcontext","link":"#applicationcontext","children":[]},{"level":3,"title":"从组件角度","slug":"从组件角度","link":"#从组件角度","children":[]},{"level":3,"title":"从一个完整请求的角度来看","slug":"从一个完整请求的角度来看","link":"#从一个完整请求的角度来看","children":[]},{"level":3,"title":"从后续深入理解的角度","slug":"从后续深入理解的角度","link":"#从后续深入理解的角度","children":[]},{"level":3,"title":"servlet引擎(容器)","slug":"servlet引擎-容器","link":"#servlet引擎-容器","children":[]},{"level":3,"title":"jsp引擎","slug":"jsp引擎","link":"#jsp引擎","children":[]},{"level":3,"title":"线程模型","slug":"线程模型","link":"#线程模型","children":[]},{"level":3,"title":"org.apache.coyote.Response","slug":"org-apache-coyote-response","link":"#org-apache-coyote-response","children":[]},{"level":3,"title":"NioEndpoint,Nio2Endpoint,AbstractEndpoint","slug":"nioendpoint-nio2endpoint-abstractendpoint","link":"#nioendpoint-nio2endpoint-abstractendpoint","children":[]},{"level":3,"title":"NioAcceptor，NioEndpoint下的accept任务","slug":"nioacceptor-nioendpoint下的accept任务","link":"#nioacceptor-nioendpoint下的accept任务","children":[]},{"level":3,"title":"SocketProcessor，NioEndpoint下的内部类","slug":"socketprocessor-nioendpoint下的内部类","link":"#socketprocessor-nioendpoint下的内部类","children":[]},{"level":3,"title":"Connector","slug":"connector","link":"#connector","children":[]},{"level":3,"title":"Http11NioProtocol,Http11Nio2Protocol,AbstractHttp11JsseProtocol,AbstractHttp11Protocol,AbstractProtocol","slug":"http11nioprotocol-http11nio2protocol-abstracthttp11jsseprotocol-abstracthttp11protocol-abstractprotocol","link":"#http11nioprotocol-http11nio2protocol-abstracthttp11jsseprotocol-abstracthttp11protocol-abstractprotocol","children":[]},{"level":3,"title":"Http11Processor,AbstractProcessorLight,Processor","slug":"http11processor-abstractprocessorlight-processor","link":"#http11processor-abstractprocessorlight-processor","children":[]},{"level":3,"title":"CoyoteAdapter","slug":"coyoteadapter","link":"#coyoteadapter","children":[]},{"level":3,"title":"LifecycleBase","slug":"lifecyclebase","link":"#lifecyclebase","children":[]},{"level":3,"title":"Container","slug":"container","link":"#container","children":[]},{"level":3,"title":"servlet3.0 异步请求","slug":"servlet3-0-异步请求","link":"#servlet3-0-异步请求","children":[]}]},{"level":2,"title":"jetty","slug":"jetty","link":"#jetty","children":[]},{"level":2,"title":"undertow","slug":"undertow","link":"#undertow","children":[]}],"git":{"createdTime":1659879518000,"updatedTime":1694143567000,"contributors":[{"name":"wanhongji","email":"wherywan@163.com","commits":1}]},"readingTime":{"minutes":3.37,"words":1012},"filePathRelative":"note/web/web服务器.md","localizedDate":"2022年8月7日","excerpt":"\\n<h2>tomcat</h2>\\n<p><a href=\\"https://www.likecs.com/show-305337039.html\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">参考</a></p>\\n<p><a href=\\"https://mp.weixin.qq.com/s?__biz=MzA5ODA0NDE2MA==&amp;mid=2649774376&amp;idx=1&amp;sn=5273159548ea223775dd3d14528e8f3a&amp;chksm=88936947bfe4e0517c1d025d4f3fff754a5e4b907dba94a0189e4591d90dbd672d7c32a92896&amp;scene=27\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">参考</a></p>","autoDesc":true}');export{k as comp,S as data};
