import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as e,c as i,e as a}from"./app-hoN0JGLf.js";const s={},l=a(`<h1 id="dubbo" tabindex="-1"><a class="header-anchor" href="#dubbo"><span>Dubbo</span></a></h1><h2 id="概念" tabindex="-1"><a class="header-anchor" href="#概念"><span>概念</span></a></h2><ul><li>Dubbo是阿里巴巴公司开源的一个高性能、轻量级的 Java RPC 框架。</li><li>致力于提供高性能和透明化的 RPC 远程服务调用方案，以及 SOA 服务治理方案</li></ul><h2 id="高级特性" tabindex="-1"><a class="header-anchor" href="#高级特性"><span>高级特性</span></a></h2><ul><li><p>dubbo底层封装了序列化与反序列化，只需实现serializable接口，服务方和消费方共同依赖，就可以实现对象传输响应。</p></li><li><p>地址缓存</p></li><li><p>超时与重试</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="shiki light-plus" style="background-color:#FFFFFF;color:#000000;" tabindex="0"><code><span class="line"><span>服务消费者在调用服务提供者的时候发生了阻塞、等待的情形，这个时候，服务消费者会一直等待下去。</span></span>
<span class="line"><span>在某个峰值时刻，大量的请求都在同时请求服务消费者，会造成线程的大量堆积，势必会造成雪崩。</span></span>
<span class="line"><span>dubbo 利用超时机制来解决这个问题，设置一个超时时间，在这个时间段内，无法完成服务访问，则自动断开连接。</span></span>
<span class="line"><span>使用timeout属性配置超时时间，默认值1000，单位毫秒。即连接超时时间和读取超时时间</span></span>
<span class="line"><span></span></span>
<span class="line"><span>设置了超时时间，在这个时间段内，无法完成服务访问，则自动断开连接。</span></span>
<span class="line"><span>如果出现网络抖动，则这一次请求就会失败。</span></span>
<span class="line"><span>Dubbo 提供重试机制来避免类似问题的发生。</span></span>
<span class="line"><span>通过 retries  属性来设置重试次数。默认为 2 次</span></span>
<span class="line"><span></span></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>多版本</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="shiki light-plus" style="background-color:#FFFFFF;color:#000000;" tabindex="0"><code><span class="line"><span>灰度发布：当出现新功能时，会让一部分用户先使用新功能，用户反馈没问题时，再将所有用户迁移到新功能。</span></span>
<span class="line"><span>dubbo 中使用version 属性来设置和调用同一个接口的不同版本</span></span>
<span class="line"><span></span></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>负载均衡</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="shiki light-plus" style="background-color:#FFFFFF;color:#000000;" tabindex="0"><code><span class="line"><span>负载均衡策略（4种）：</span></span>
<span class="line"><span>Random ：按权重随机，默认值。按权重设置随机概率。</span></span>
<span class="line"><span>RoundRobin ：按权重轮询。</span></span>
<span class="line"><span>LeastActive：最少活跃调用数，相同活跃数的随机。</span></span>
<span class="line"><span>ConsistentHash：一致性 Hash，相同参数的请求总是发到同一提供者。</span></span>
<span class="line"><span></span></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>集群容错</p><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="shiki light-plus" style="background-color:#FFFFFF;color:#000000;" tabindex="0"><code><span class="line"><span>集群容错模式：</span></span>
<span class="line"><span>Failover Cluster：失败重试。默认值。当出现失败，重试其它服务器 ，默认重试2次，使用 retries 配置。一般用于读操作</span></span>
<span class="line"><span>Failfast Cluster ：快速失败，只发起一次调用，失败立即报错。通常用于写操作。</span></span>
<span class="line"><span>Failsafe Cluster ：失败安全，出现异常时，直接忽略。返回一个空结果。</span></span>
<span class="line"><span>Failback Cluster ：失败自动恢复，后台记录失败请求，定时重发。通常用于消息通知操作。</span></span>
<span class="line"><span>Forking Cluster ：并行调用多个服务器，只要一个成功即返回。</span></span>
<span class="line"><span>Broadcast  Cluster ：广播调用所有提供者，逐个调用，任意一台报错则报错。</span></span>
<span class="line"><span></span></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>服务降级</p></li></ul><h2 id="原理" tabindex="-1"><a class="header-anchor" href="#原理"><span>原理</span></a></h2><h3 id="代理类生成" tabindex="-1"><a class="header-anchor" href="#代理类生成"><span>代理类生成</span></a></h3><ul><li>javaassist</li><li>jdk动态代理</li></ul><h3 id="springboot方式初始化" tabindex="-1"><a class="header-anchor" href="#springboot方式初始化"><span>springboot方式初始化</span></a></h3><ul><li>Model</li><li>context</li><li>config</li><li>deploy</li></ul><h3 id="model模型" tabindex="-1"><a class="header-anchor" href="#model模型"><span>Model模型</span></a></h3><p>通过spi的方式，加载配置类、功能类、拓展类到jvm,并创建实例进行管理</p><h4 id="scopemodel、framemodel、applicationmodel、modulemodel" tabindex="-1"><a class="header-anchor" href="#scopemodel、framemodel、applicationmodel、modulemodel"><span>ScopeModel、FrameModel、ApplicationModel、ModuleModel</span></a></h4><p>模型有父子级关系，每个模型Model、内部的ScopeBeanFactory、ExtensionDirector都记录了父级实例,父模型记录子模型</p><ul><li>ScopeBeanFactory</li><li>ExtensionDirector</li></ul><h4 id="extensiondirector" tabindex="-1"><a class="header-anchor" href="#extensiondirector"><span>ExtensionDirector</span></a></h4><ul><li>ExtensionDirector负责创建并管理相应scope级别、相应类型的ExtensionLoader,</li><li>获取loader优先查找当前对象，没有从父级ExtensionDirector查找，最后没有再创建</li><li>ExtensionInjector类型的ExtensionLoader属于顶级loader，用于加载Injector类型的extension类，并创建管理适配器注入器adaptiveExtensionInjector <ul><li>SpiExtensionInjector</li><li>ScopeBeanExtensionInjector</li><li>SpringExtensionInjector</li></ul></li><li>其余类型的ExtensionLoader都会使用ExtensionInjector类型的ExtensionLoader的adaptiveExtensionInjector作为injector</li></ul><h4 id="extensionloader" tabindex="-1"><a class="header-anchor" href="#extensionloader"><span>ExtensionLoader</span></a></h4><ul><li>根据相应的load加载策略,加载对应类型的类进行管理，并缓存类对象，以及实例对象</li><li>ExtensionLoader类型有scope(frame、model、module),被不同ExtensionDirector管理</li></ul><h3 id="dubbospringinitializer" tabindex="-1"><a class="header-anchor" href="#dubbospringinitializer"><span>DubboSpringInitializer</span></a></h3><ul><li>初始化dubbo上下文</li><li>创建applicationModel、moduleModel</li><li>注册上下文和模型对象到容器的单例对象集合中</li><li>注册基础配置对象到beanDefinition <ul><li>ServicePackagesHolder</li><li>ReferenceAnnotationBeanPostProcessor</li><li>ReferenceBeanManager</li><li>DubboDeployApplicationListener</li><li>DubboConfigApplicationListener</li><li>DubboConfigBeanInitializer</li><li>DubboInfraBeanRegisterPostProcessor</li></ul></li></ul><h3 id="serviceannotationpostprocessor" tabindex="-1"><a class="header-anchor" href="#serviceannotationpostprocessor"><span>ServiceAnnotationPostProcessor</span></a></h3><p>处理@DubboService注解，生成对应service的服务代理对象提供服务，用于rpc的服务</p><h3 id="dubboinfrabeanregisterpostprocessor" tabindex="-1"><a class="header-anchor" href="#dubboinfrabeanregisterpostprocessor"><span>DubboInfraBeanRegisterPostProcessor</span></a></h3><ul><li>对提前创建好的Model、Dubbo上下文初始化ApplicationContext</li><li>设置dubboProperties到ApplicationModel的ModelEnvironment中</li><li>注册ConfigManager到单例对象集合中</li></ul><h3 id="referenceannotationbeanpostprocessor" tabindex="-1"><a class="header-anchor" href="#referenceannotationbeanpostprocessor"><span>ReferenceAnnotationBeanPostProcessor</span></a></h3><ul><li>处理@DubboRefrence注解，生成对应接口的代理对象，用于rpc请求调用</li><li>发送Config初始化事件到DubboConfigApplicationListener</li></ul><h3 id="dubbodeployapplicationlistener" tabindex="-1"><a class="header-anchor" href="#dubbodeployapplicationlistener"><span>DubboDeployApplicationListener</span></a></h3><ul><li>注册DeployListenerAdapter监听器到deployer中，用于发布相应部署事件</li><li>监听应用上下文已刷新事件</li><li>启动Model <ul><li>发布模块启动事件</li><li>exportServices</li><li>referServices</li><li>模块已启动事件</li></ul></li></ul><h3 id="dubboconfigapplicationlistener" tabindex="-1"><a class="header-anchor" href="#dubboconfigapplicationlistener"><span>DubboConfigApplicationListener</span></a></h3><ul><li>监听配置初始化事件，并获取DubboConfigBeanInitializer对象触发afterProperties初始化</li><li>所有配置、功能bean已初始化，部署dubbo</li></ul><h3 id="deploy" tabindex="-1"><a class="header-anchor" href="#deploy"><span>deploy</span></a></h3><ul><li>获取模型中moduleDeployer、applicationDeployer进行部署</li><li>调用Deployer的initialize方法进行初始化</li><li>applicationDeployer的初始化 <ul><li>触发deploy状态事件</li><li>初始化配置，获取applicationConfig,registryConfig</li><li>获取配置中心配置，若没有配置中心配置，使用registryConfig作为配置中心配置，启动配置中心，从配置中心获取配置</li><li>startMetadataCenter启用元数据中心</li></ul></li></ul><h3 id="protocol" tabindex="-1"><a class="header-anchor" href="#protocol"><span>protocol</span></a></h3><ul><li>DubboProtocol</li><li>GrpcProtocol</li><li>RestProtocol</li></ul>`,35),o=[l];function t(p,r){return e(),i("div",null,o)}const b=n(s,[["render",t],["__file","dubbo.html.vue"]]),u=JSON.parse('{"path":"/note/%E4%B8%AD%E9%97%B4%E4%BB%B6/dubbo.html","title":"Dubbo","lang":"zh-CN","frontmatter":{"description":"Dubbo 概念 Dubbo是阿里巴巴公司开源的一个高性能、轻量级的 Java RPC 框架。 致力于提供高性能和透明化的 RPC 远程服务调用方案，以及 SOA 服务治理方案 高级特性 dubbo底层封装了序列化与反序列化，只需实现serializable接口，服务方和消费方共同依赖，就可以实现对象传输响应。 地址缓存 超时与重试 多版本 负载均衡 ...","head":[["meta",{"property":"og:url","content":"https://wherywan.github.io/note/%E4%B8%AD%E9%97%B4%E4%BB%B6/dubbo.html"}],["meta",{"property":"og:site_name","content":"HONG_JI"}],["meta",{"property":"og:title","content":"Dubbo"}],["meta",{"property":"og:description","content":"Dubbo 概念 Dubbo是阿里巴巴公司开源的一个高性能、轻量级的 Java RPC 框架。 致力于提供高性能和透明化的 RPC 远程服务调用方案，以及 SOA 服务治理方案 高级特性 dubbo底层封装了序列化与反序列化，只需实现serializable接口，服务方和消费方共同依赖，就可以实现对象传输响应。 地址缓存 超时与重试 多版本 负载均衡 ..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-04-25T16:34:12.000Z"}],["meta",{"property":"article:author","content":"wanhongji"}],["meta",{"property":"article:modified_time","content":"2024-04-25T16:34:12.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Dubbo\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-04-25T16:34:12.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"wanhongji\\"}]}"]]},"headers":[{"level":2,"title":"概念","slug":"概念","link":"#概念","children":[]},{"level":2,"title":"高级特性","slug":"高级特性","link":"#高级特性","children":[]},{"level":2,"title":"原理","slug":"原理","link":"#原理","children":[{"level":3,"title":"代理类生成","slug":"代理类生成","link":"#代理类生成","children":[]},{"level":3,"title":"springboot方式初始化","slug":"springboot方式初始化","link":"#springboot方式初始化","children":[]},{"level":3,"title":"Model模型","slug":"model模型","link":"#model模型","children":[]},{"level":3,"title":"DubboSpringInitializer","slug":"dubbospringinitializer","link":"#dubbospringinitializer","children":[]},{"level":3,"title":"ServiceAnnotationPostProcessor","slug":"serviceannotationpostprocessor","link":"#serviceannotationpostprocessor","children":[]},{"level":3,"title":"DubboInfraBeanRegisterPostProcessor","slug":"dubboinfrabeanregisterpostprocessor","link":"#dubboinfrabeanregisterpostprocessor","children":[]},{"level":3,"title":"ReferenceAnnotationBeanPostProcessor","slug":"referenceannotationbeanpostprocessor","link":"#referenceannotationbeanpostprocessor","children":[]},{"level":3,"title":"DubboDeployApplicationListener","slug":"dubbodeployapplicationlistener","link":"#dubbodeployapplicationlistener","children":[]},{"level":3,"title":"DubboConfigApplicationListener","slug":"dubboconfigapplicationlistener","link":"#dubboconfigapplicationlistener","children":[]},{"level":3,"title":"deploy","slug":"deploy","link":"#deploy","children":[]},{"level":3,"title":"protocol","slug":"protocol","link":"#protocol","children":[]}]}],"git":{"createdTime":1657433155000,"updatedTime":1714062852000,"contributors":[{"name":"wanhongji","email":"wan_hongji@163.com","commits":1},{"name":"wanhongji","email":"wherywan@163.com","commits":1}]},"readingTime":{"minutes":4.17,"words":1252},"filePathRelative":"note/中间件/dubbo.md","localizedDate":"2022年7月10日","excerpt":"\\n<h2>概念</h2>\\n<ul>\\n<li>Dubbo是阿里巴巴公司开源的一个高性能、轻量级的 Java RPC 框架。</li>\\n<li>致力于提供高性能和透明化的 RPC 远程服务调用方案，以及 SOA 服务治理方案</li>\\n</ul>\\n<h2>高级特性</h2>\\n<ul>\\n<li>\\n<p>dubbo底层封装了序列化与反序列化，只需实现serializable接口，服务方和消费方共同依赖，就可以实现对象传输响应。</p>\\n</li>\\n<li>\\n<p>地址缓存</p>\\n</li>\\n<li>\\n<p>超时与重试</p>\\n<div class=\\"language-text line-numbers-mode\\" data-ext=\\"text\\" data-title=\\"text\\"><pre class=\\"shiki light-plus\\" style=\\"background-color:#FFFFFF;color:#000000\\" tabindex=\\"0\\"><code><span class=\\"line\\"><span>服务消费者在调用服务提供者的时候发生了阻塞、等待的情形，这个时候，服务消费者会一直等待下去。</span></span>\\n<span class=\\"line\\"><span>在某个峰值时刻，大量的请求都在同时请求服务消费者，会造成线程的大量堆积，势必会造成雪崩。</span></span>\\n<span class=\\"line\\"><span>dubbo 利用超时机制来解决这个问题，设置一个超时时间，在这个时间段内，无法完成服务访问，则自动断开连接。</span></span>\\n<span class=\\"line\\"><span>使用timeout属性配置超时时间，默认值1000，单位毫秒。即连接超时时间和读取超时时间</span></span>\\n<span class=\\"line\\"><span></span></span>\\n<span class=\\"line\\"><span>设置了超时时间，在这个时间段内，无法完成服务访问，则自动断开连接。</span></span>\\n<span class=\\"line\\"><span>如果出现网络抖动，则这一次请求就会失败。</span></span>\\n<span class=\\"line\\"><span>Dubbo 提供重试机制来避免类似问题的发生。</span></span>\\n<span class=\\"line\\"><span>通过 retries  属性来设置重试次数。默认为 2 次</span></span>\\n<span class=\\"line\\"><span></span></span></code></pre><div class=\\"line-numbers\\" aria-hidden=\\"true\\"><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div></div></div></li>\\n<li>\\n<p>多版本</p>\\n<div class=\\"language-text line-numbers-mode\\" data-ext=\\"text\\" data-title=\\"text\\"><pre class=\\"shiki light-plus\\" style=\\"background-color:#FFFFFF;color:#000000\\" tabindex=\\"0\\"><code><span class=\\"line\\"><span>灰度发布：当出现新功能时，会让一部分用户先使用新功能，用户反馈没问题时，再将所有用户迁移到新功能。</span></span>\\n<span class=\\"line\\"><span>dubbo 中使用version 属性来设置和调用同一个接口的不同版本</span></span>\\n<span class=\\"line\\"><span></span></span></code></pre><div class=\\"line-numbers\\" aria-hidden=\\"true\\"><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div></div></div></li>\\n<li>\\n<p>负载均衡</p>\\n<div class=\\"language-text line-numbers-mode\\" data-ext=\\"text\\" data-title=\\"text\\"><pre class=\\"shiki light-plus\\" style=\\"background-color:#FFFFFF;color:#000000\\" tabindex=\\"0\\"><code><span class=\\"line\\"><span>负载均衡策略（4种）：</span></span>\\n<span class=\\"line\\"><span>Random ：按权重随机，默认值。按权重设置随机概率。</span></span>\\n<span class=\\"line\\"><span>RoundRobin ：按权重轮询。</span></span>\\n<span class=\\"line\\"><span>LeastActive：最少活跃调用数，相同活跃数的随机。</span></span>\\n<span class=\\"line\\"><span>ConsistentHash：一致性 Hash，相同参数的请求总是发到同一提供者。</span></span>\\n<span class=\\"line\\"><span></span></span></code></pre><div class=\\"line-numbers\\" aria-hidden=\\"true\\"><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div></div></div></li>\\n<li>\\n<p>集群容错</p>\\n<div class=\\"language-text line-numbers-mode\\" data-ext=\\"text\\" data-title=\\"text\\"><pre class=\\"shiki light-plus\\" style=\\"background-color:#FFFFFF;color:#000000\\" tabindex=\\"0\\"><code><span class=\\"line\\"><span>集群容错模式：</span></span>\\n<span class=\\"line\\"><span>Failover Cluster：失败重试。默认值。当出现失败，重试其它服务器 ，默认重试2次，使用 retries 配置。一般用于读操作</span></span>\\n<span class=\\"line\\"><span>Failfast Cluster ：快速失败，只发起一次调用，失败立即报错。通常用于写操作。</span></span>\\n<span class=\\"line\\"><span>Failsafe Cluster ：失败安全，出现异常时，直接忽略。返回一个空结果。</span></span>\\n<span class=\\"line\\"><span>Failback Cluster ：失败自动恢复，后台记录失败请求，定时重发。通常用于消息通知操作。</span></span>\\n<span class=\\"line\\"><span>Forking Cluster ：并行调用多个服务器，只要一个成功即返回。</span></span>\\n<span class=\\"line\\"><span>Broadcast  Cluster ：广播调用所有提供者，逐个调用，任意一台报错则报错。</span></span>\\n<span class=\\"line\\"><span></span></span></code></pre><div class=\\"line-numbers\\" aria-hidden=\\"true\\"><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div></div></div></li>\\n<li>\\n<p>服务降级</p>\\n</li>\\n</ul>","autoDesc":true}');export{b as comp,u as data};
