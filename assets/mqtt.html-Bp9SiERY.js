import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as n,c as t,e as l}from"./app-hoN0JGLf.js";const a={},i=l(`<h1 id="mqtt" tabindex="-1"><a class="header-anchor" href="#mqtt"><span>mqtt</span></a></h1><h2 id="paho-mqtt5-client" tabindex="-1"><a class="header-anchor" href="#paho-mqtt5-client"><span>paho-mqtt5-client</span></a></h2><p>ClientState是核心，类似于中介者,CommsReceiver和CommsSender与其交互获取消息</p><h3 id="mqttasyncclient" tabindex="-1"><a class="header-anchor" href="#mqttasyncclient"><span>MqttAsyncClient</span></a></h3><blockquote><p>connect方法</p></blockquote><ul><li>准备ClientComms</li><li>设置网络模块</li><li>重连回调</li><li>connectActionListener#connect进行连接</li></ul><blockquote><p>startReconnectCycle</p></blockquote><h3 id="mqttasyncclient下的mqttreconnectcallback" tabindex="-1"><a class="header-anchor" href="#mqttasyncclient下的mqttreconnectcallback"><span>MqttAsyncClient下的MqttReconnectCallback</span></a></h3><p>判断是否自动重连，调用startReconnectCycle方法</p><h3 id="mqtttoken" tabindex="-1"><a class="header-anchor" href="#mqtttoken"><span>MqttToken</span></a></h3><ul><li>setActionCallback设置回调</li></ul><h3 id="tokenstore" tabindex="-1"><a class="header-anchor" href="#tokenstore"><span>TokenStore</span></a></h3><h3 id="mqttpingreq" tabindex="-1"><a class="header-anchor" href="#mqttpingreq"><span>MqttPingReq</span></a></h3><h3 id="clientstate" tabindex="-1"><a class="header-anchor" href="#clientstate"><span>ClientState</span></a></h3><blockquote><p>属性</p></blockquote><ul><li>pingOutStanding ping的次数</li><li>lastInboundActivity 最后收到消息时间</li><li>lastOutboundActivity 最后发送消息时间</li><li>inUseMsgIds 已使用消息id列表</li><li>pendingFlows 其他要发送的消息</li><li>pendingMessages 存放要发布的消息</li><li>actualInFlight</li></ul><blockquote><p>方法</p></blockquote><ul><li>checkForActivity方法,校验是否超过保活时间，在保活时间内发送ping到server验证server是否存活</li><li>send方法</li><li>notifySent方法 被CommsSender调用 消息已发送</li><li>notifyReceivedMsg方法 被CommsSender调用 消息已到达</li></ul><h4 id="send方法" tabindex="-1"><a class="header-anchor" href="#send方法"><span>send方法</span></a></h4><ul><li>设置消息id</li><li>校验消息类型为MqttPublish、MqttConnect</li></ul><h3 id="connectactionlister" tabindex="-1"><a class="header-anchor" href="#connectactionlister"><span>ConnectActionLister</span></a></h3><ul><li>connect方法,创建token,调用ClientComms的connect方法</li></ul><h3 id="clientcomms" tabindex="-1"><a class="header-anchor" href="#clientcomms"><span>ClientComms</span></a></h3><blockquote><p>实例化时</p></blockquote><ul><li>创建tokenstore</li><li>创建callback回调</li><li>创建clientState</li><li>callback回调中设置clientState</li></ul><h4 id="connect方法" tabindex="-1"><a class="header-anchor" href="#connect方法"><span>connect方法</span></a></h4><ul><li>准备连接信息对象MqttConnect</li><li>创建ConnectBG对象，并启动</li></ul><h4 id="internalsend方法" tabindex="-1"><a class="header-anchor" href="#internalsend方法"><span>internalSend方法</span></a></h4><p>调用clientState的send方法</p><h4 id="checkforactivity-检查活跃度" tabindex="-1"><a class="header-anchor" href="#checkforactivity-检查活跃度"><span>checkForActivity 检查活跃度</span></a></h4><h4 id="shutdownconnection方法" tabindex="-1"><a class="header-anchor" href="#shutdownconnection方法"><span>shutdownConnection方法</span></a></h4><p>被CommsReceiver触发调用</p><h3 id="clientcomms-connectbg" tabindex="-1"><a class="header-anchor" href="#clientcomms-connectbg"><span>ClientComms#ConnectBG</span></a></h3><p>核心类，它是一个内部私有类</p><h4 id="run" tabindex="-1"><a class="header-anchor" href="#run"><span>run</span></a></h4><ul><li>缓存token 即以要发送消息的key作为键，token作为值</li><li>启动网络模块connect</li><li>启动receiver、sender、callback线程</li><li>internalSend发送验证信息进行验证</li></ul><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="shiki light-plus" style="background-color:#FFFFFF;color:#000000;" tabindex="0"><code><span class="line"><span>public void run() {</span></span>
<span class="line"><span>        Thread.currentThread().setName(threadName);</span></span>
<span class="line"><span>        final String methodName = &quot;connectBG:run&quot;;</span></span>
<span class="line"><span>        MqttException mqttEx = null;</span></span>
<span class="line"><span>        // @TRACE 220=&gt;</span></span>
<span class="line"><span>        log.fine(CLASS_NAME, methodName, &quot;220&quot;);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        try {</span></span>
<span class="line"><span>            // Reset an exception on existing delivery tokens.</span></span>
<span class="line"><span>            // This will have been set if disconnect occurred before delivery was</span></span>
<span class="line"><span>            // fully processed.</span></span>
<span class="line"><span>            MqttToken[] toks = tokenStore.getOutstandingDelTokens();</span></span>
<span class="line"><span>            for (MqttToken tok : toks) {</span></span>
<span class="line"><span>                tok.internalTok.setException(null);</span></span>
<span class="line"><span>            }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>            // Save the connect token in tokenStore as failure can occur before send</span></span>
<span class="line"><span>            tokenStore.saveToken(conToken, conPacket);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>            // Connect to the server at the network level e.g. TCP socket and then</span></span>
<span class="line"><span>            // start the background processing threads before sending the connect</span></span>
<span class="line"><span>            // packet.</span></span>
<span class="line"><span>            NetworkModule networkModule = networkModules[networkModuleIndex];</span></span>
<span class="line"><span>            networkModule.start();</span></span>
<span class="line"><span>            receiver = new CommsReceiver(clientComms, clientState, tokenStore, networkModule.getInputStream());</span></span>
<span class="line"><span>            receiver.start(&quot;MQTT Rec: &quot; + getClient().getClientId(), executorService);</span></span>
<span class="line"><span>            sender = new CommsSender(clientComms, clientState, tokenStore, networkModule.getOutputStream());</span></span>
<span class="line"><span>            sender.start(&quot;MQTT Snd: &quot; + getClient().getClientId(), executorService);</span></span>
<span class="line"><span>            callback.start(&quot;MQTT Call: &quot; + getClient().getClientId(), executorService);</span></span>
<span class="line"><span>            internalSend(conPacket, conToken);</span></span>
<span class="line"><span>        } catch (MqttException ex) {</span></span>
<span class="line"><span>            // @TRACE 212=connect failed: unexpected exception</span></span>
<span class="line"><span>            log.fine(CLASS_NAME, methodName, &quot;212&quot;, null, ex);</span></span>
<span class="line"><span>            mqttEx = ex;</span></span>
<span class="line"><span>        } catch (Exception ex) {</span></span>
<span class="line"><span>            // @TRACE 209=connect failed: unexpected exception</span></span>
<span class="line"><span>            log.fine(CLASS_NAME, methodName, &quot;209&quot;, null, ex);</span></span>
<span class="line"><span>            mqttEx = ExceptionHelper.createMqttException(ex);</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        if (mqttEx != null) {</span></span>
<span class="line"><span>            shutdownConnection(conToken, mqttEx, null);</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="commscallback" tabindex="-1"><a class="header-anchor" href="#commscallback"><span>CommsCallback</span></a></h3><ul><li>completeQueue完成队列，触发ConnectedComplete的方法的前置判断</li><li>messageArrived方法，增加消息到messageQueue,注意如果消息队列中消息大于10条，这里会自旋等待</li><li>connectionLost 触发重连回调</li><li>run方法，循环消费消息</li></ul><h3 id="commssender" tabindex="-1"><a class="header-anchor" href="#commssender"><span>CommsSender</span></a></h3><ul><li>start()</li><li>stop</li><li>run方法</li></ul><h4 id="run-1" tabindex="-1"><a class="header-anchor" href="#run-1"><span>run</span></a></h4><ul><li>调用ClientState的get方法获取要发送的消息</li><li>使用OutputStream将消息发送出去</li><li>调用ClientState的notifySent方法</li></ul><h3 id="commsreceiver" tabindex="-1"><a class="header-anchor" href="#commsreceiver"><span>CommsReceiver</span></a></h3><ul><li>start</li><li>stop</li><li>run</li></ul><h4 id="run-2" tabindex="-1"><a class="header-anchor" href="#run-2"><span>run</span></a></h4><ul><li>从输入流中获取字节数据转为消息对象</li><li>判断消息类型，调用回调Callback相应的方法</li></ul><h3 id="mqttinputstream" tabindex="-1"><a class="header-anchor" href="#mqttinputstream"><span>MqttInputStream</span></a></h3><ul><li>DataInputStream</li><li>ByteArrayOutputStream</li><li>readMqttWireMessage</li></ul><h3 id="tcpnetworkmodule实现networkmodule" tabindex="-1"><a class="header-anchor" href="#tcpnetworkmodule实现networkmodule"><span>TcpNetworkModule实现NetworkModule</span></a></h3><ul><li>socket属性</li><li>SocketFactory</li><li>start方法 创建socket，连接服务器</li></ul><h3 id="timer" tabindex="-1"><a class="header-anchor" href="#timer"><span>Timer</span></a></h3><p>定时器主要用于延迟执行任务</p><h4 id="timer-timerthread" tabindex="-1"><a class="header-anchor" href="#timer-timerthread"><span>Timer#TimerThread</span></a></h4><ul><li>TaskQueue任务队列</li><li>run方法 执行mainLoop</li><li>mainLoop方法,从任务队列获取任务执行</li></ul><h3 id="timerpingsender" tabindex="-1"><a class="header-anchor" href="#timerpingsender"><span>TimerPingSender</span></a></h3><p>定时ping发送器</p><blockquote><p>方法</p></blockquote><ul><li>init 初始化设置ClientComms对象</li><li>start 启动延迟执行任务</li><li>stop</li><li>schedule 选择使用哪种延时执行器</li></ul><blockquote><p>内部类</p></blockquote><ul><li>PingTask类实现TimerTask接口</li><li>PingRunnable实现Runnable接口</li></ul><h2 id="重复订阅分析" tabindex="-1"><a class="header-anchor" href="#重复订阅分析"><span>重复订阅分析</span></a></h2><h3 id="设置保活时间间隔keepaliveinterval作用" tabindex="-1"><a class="header-anchor" href="#设置保活时间间隔keepaliveinterval作用"><span>设置保活时间间隔keepAliveInterval作用</span></a></h3><ol><li>客户端判断broker是否存活</li><li>服务器判断是否客户端存活</li><li>emq的处理是1.5倍保活时间内未收到客户端任何报文则断开连接</li></ol><h3 id="原因" tabindex="-1"><a class="header-anchor" href="#原因"><span>原因</span></a></h3><ol><li>开启重连问题</li><li>在回调中进行订阅的问题，可能性不大，因为订阅是异步，并不会阻塞</li><li>broker断开连接，导致重复连接</li><li>同一clientid问题</li><li>模拟器和设备调试的客户端id相同问题</li><li>emqx版本问题</li></ol><h3 id="解决方法" tabindex="-1"><a class="header-anchor" href="#解决方法"><span>解决方法</span></a></h3><ol><li>尝试关闭保活间隔，但会导致连接状态不准确</li></ol><h3 id="已定位问题-解决方案" tabindex="-1"><a class="header-anchor" href="#已定位问题-解决方案"><span>已定位问题，解决方案</span></a></h3><ul><li>由于重连时，订阅主题为空，导致客户端收到服务端断开连接的143响应，断开连接shutdownConnection，触发callback的connectionLost方法进行重连startReconnectCycle</li><li>重连时判断订阅主题是否为空</li></ul>`,70),s=[i];function c(o,r){return n(),t("div",null,s)}const m=e(a,[["render",c],["__file","mqtt.html.vue"]]),h=JSON.parse('{"path":"/note/%E4%B8%AD%E9%97%B4%E4%BB%B6/mqtt.html","title":"mqtt","lang":"zh-CN","frontmatter":{"description":"mqtt paho-mqtt5-client ClientState是核心，类似于中介者,CommsReceiver和CommsSender与其交互获取消息 MqttAsyncClient connect方法 准备ClientComms 设置网络模块 重连回调 connectActionListener#connect进行连接 startReconne...","head":[["meta",{"property":"og:url","content":"https://wherywan.github.io/note/%E4%B8%AD%E9%97%B4%E4%BB%B6/mqtt.html"}],["meta",{"property":"og:site_name","content":"HONG_JI"}],["meta",{"property":"og:title","content":"mqtt"}],["meta",{"property":"og:description","content":"mqtt paho-mqtt5-client ClientState是核心，类似于中介者,CommsReceiver和CommsSender与其交互获取消息 MqttAsyncClient connect方法 准备ClientComms 设置网络模块 重连回调 connectActionListener#connect进行连接 startReconne..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-08-13T02:49:09.000Z"}],["meta",{"property":"article:author","content":"wanhongji"}],["meta",{"property":"article:modified_time","content":"2023-08-13T02:49:09.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"mqtt\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2023-08-13T02:49:09.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"wanhongji\\"}]}"]]},"headers":[{"level":2,"title":"paho-mqtt5-client","slug":"paho-mqtt5-client","link":"#paho-mqtt5-client","children":[{"level":3,"title":"MqttAsyncClient","slug":"mqttasyncclient","link":"#mqttasyncclient","children":[]},{"level":3,"title":"MqttAsyncClient下的MqttReconnectCallback","slug":"mqttasyncclient下的mqttreconnectcallback","link":"#mqttasyncclient下的mqttreconnectcallback","children":[]},{"level":3,"title":"MqttToken","slug":"mqtttoken","link":"#mqtttoken","children":[]},{"level":3,"title":"TokenStore","slug":"tokenstore","link":"#tokenstore","children":[]},{"level":3,"title":"MqttPingReq","slug":"mqttpingreq","link":"#mqttpingreq","children":[]},{"level":3,"title":"ClientState","slug":"clientstate","link":"#clientstate","children":[]},{"level":3,"title":"ConnectActionLister","slug":"connectactionlister","link":"#connectactionlister","children":[]},{"level":3,"title":"ClientComms","slug":"clientcomms","link":"#clientcomms","children":[]},{"level":3,"title":"ClientComms#ConnectBG","slug":"clientcomms-connectbg","link":"#clientcomms-connectbg","children":[]},{"level":3,"title":"CommsCallback","slug":"commscallback","link":"#commscallback","children":[]},{"level":3,"title":"CommsSender","slug":"commssender","link":"#commssender","children":[]},{"level":3,"title":"CommsReceiver","slug":"commsreceiver","link":"#commsreceiver","children":[]},{"level":3,"title":"MqttInputStream","slug":"mqttinputstream","link":"#mqttinputstream","children":[]},{"level":3,"title":"TcpNetworkModule实现NetworkModule","slug":"tcpnetworkmodule实现networkmodule","link":"#tcpnetworkmodule实现networkmodule","children":[]},{"level":3,"title":"Timer","slug":"timer","link":"#timer","children":[]},{"level":3,"title":"TimerPingSender","slug":"timerpingsender","link":"#timerpingsender","children":[]}]},{"level":2,"title":"重复订阅分析","slug":"重复订阅分析","link":"#重复订阅分析","children":[{"level":3,"title":"设置保活时间间隔keepAliveInterval作用","slug":"设置保活时间间隔keepaliveinterval作用","link":"#设置保活时间间隔keepaliveinterval作用","children":[]},{"level":3,"title":"原因","slug":"原因","link":"#原因","children":[]},{"level":3,"title":"解决方法","slug":"解决方法","link":"#解决方法","children":[]},{"level":3,"title":"已定位问题，解决方案","slug":"已定位问题-解决方案","link":"#已定位问题-解决方案","children":[]}]}],"git":{"createdTime":1691834355000,"updatedTime":1691894949000,"contributors":[{"name":"wanhongji","email":"wherywan@163.com","commits":3}]},"readingTime":{"minutes":3.43,"words":1028},"filePathRelative":"note/中间件/mqtt.md","localizedDate":"2023年8月12日","excerpt":"\\n<h2>paho-mqtt5-client</h2>\\n<p>ClientState是核心，类似于中介者,CommsReceiver和CommsSender与其交互获取消息</p>\\n<h3>MqttAsyncClient</h3>\\n<blockquote>\\n<p>connect方法</p>\\n</blockquote>\\n<ul>\\n<li>准备ClientComms</li>\\n<li>设置网络模块</li>\\n<li>重连回调</li>\\n<li>connectActionListener#connect进行连接</li>\\n</ul>\\n<blockquote>\\n<p>startReconnectCycle</p>\\n</blockquote>","autoDesc":true}');export{m as comp,h as data};
