import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{o as a,c as n,e}from"./app-hoN0JGLf.js";const i={},t=e(`<h1 id="vue" tabindex="-1"><a class="header-anchor" href="#vue"><span>vue</span></a></h1><h2 id="状态" tabindex="-1"><a class="header-anchor" href="#状态"><span>状态</span></a></h2><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="shiki light-plus" style="background-color:#FFFFFF;color:#000000;" tabindex="0"><code><span class="line"><span>vuex是vue中的状态管理模式，统一管理多个组件共享的状态。</span></span>
<span class="line"><span>vuex状态管理模式的核心是store实例相当于应用的仓库，主要有四种属性：</span></span>
<span class="line"><span>state对象，多组件共享的状态，通过this.$store.的方式或通过辅助函数mapState将state属性映射到组件的计算属性</span></span>
<span class="line"><span>getters属性，类似于vue的计算属性，它会根据依赖的改变实时变更getter属性的值，即vuex的状态存储是响应式的，通过辅助函数mapGetter将getter属性映射到组件的计算属性</span></span>
<span class="line"><span>mutations属性类型于有名称的事件，通过commmit方法触发，用于改变store中state的属性状态，通过辅助函数mapMutation将触发方法映射到组件的方法属性，注意mutations是</span></span>
<span class="line"><span>--同步的，即mutation事件中不可使用回调函数，因为判断不了回调函数何时执行，何时执行完成，进而无法及时变更store中state状态</span></span>
<span class="line"><span>万物皆对象，函数属性存放的是函数的地址</span></span>
<span class="line"><span>actions与mutations类似，用于触发mutations事件，且可以执行异步操作，使用await/async,其中dispatch可以处理action事件传回的promise对象，且自己也可以返回promise</span></span>
<span class="line"><span>--对象，调用then方法执行后续操作,，通过辅助函数mapActions将触发方法dispatch映射到组件的方法属性，</span></span>
<span class="line"><span>module模块可以解决state对象非常臃肿的问题，使用store.state.模块名.模块名.状态属性访问状态，模块中可以嵌套模块，带有命名空间的模块</span></span>
<span class="line"><span>可以通过将store实例放入vue根实例的方式将状态实例注入到每一个组件</span></span>
<span class="line"><span>双向绑定的数据对象的数据对象的数据类型，影响赋值</span></span>
<span class="line"><span>v-auth权限控制若放在元素首部，可能会失效</span></span>
<span class="line"><span></span></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="通信" tabindex="-1"><a class="header-anchor" href="#通信"><span>通信</span></a></h2><ul><li>axios</li><li>qs处理参数</li></ul><h2 id="异步" tabindex="-1"><a class="header-anchor" href="#异步"><span>异步</span></a></h2><div class="language-text line-numbers-mode" data-ext="text" data-title="text"><pre class="shiki light-plus" style="background-color:#FFFFFF;color:#000000;" tabindex="0"><code><span class="line"><span>promise对象本身是同步的，.then.catch方法是异步的</span></span>
<span class="line"><span>当promise对象创建完成后，其内部的executor函数会立即执行</span></span>
<span class="line"><span>通常在其中放入异步操作，使用resolve，reject告诉promise，改变状态</span></span>
<span class="line"><span>await，async，promise息息相关，await只能在async函数中使用，当执行到await时async函数会挂起，</span></span>
<span class="line"><span>等待await右侧的表达式返回promise或对象</span></span>
<span class="line"><span></span></span></code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="问题" tabindex="-1"><a class="header-anchor" href="#问题"><span>问题</span></a></h2><h3 id="vue父子组件传值不刷新问题" tabindex="-1"><a class="header-anchor" href="#vue父子组件传值不刷新问题"><span>vue父子组件传值不刷新问题</span></a></h3><p>1、在父组件改变子组件的值后，立即调用子组件方法获取最新的值，结果获取不到，获取的是旧值 注意双向绑定和属性绑定的区别，以数据驱动的模型,数据改变组件刷新</p><p>解决方案：</p><ul><li>1、强制刷新数据，$set,v-if</li><li>2、在子组件中监听父组件传入的值，当值改变时进行操作</li><li>3、改变key的值</li><li>4、this.$nextTick,在组件渲染后执行</li><li>5、延时操作setTimeout</li></ul>`,12),l=[t];function p(c,r){return a(),n("div",null,l)}const u=s(i,[["render",p],["__file","vue.html.vue"]]),v=JSON.parse('{"path":"/note/%E5%89%8D%E7%AB%AF/vue.html","title":"vue","lang":"zh-CN","frontmatter":{"description":"vue 状态 通信 axios qs处理参数 异步 问题 vue父子组件传值不刷新问题 1、在父组件改变子组件的值后，立即调用子组件方法获取最新的值，结果获取不到，获取的是旧值 注意双向绑定和属性绑定的区别，以数据驱动的模型,数据改变组件刷新 解决方案： 1、强制刷新数据，$set,v-if 2、在子组件中监听父组件传入的值，当值改变时进行操作 3、改...","head":[["meta",{"property":"og:url","content":"https://wherywan.github.io/note/%E5%89%8D%E7%AB%AF/vue.html"}],["meta",{"property":"og:site_name","content":"HONG_JI"}],["meta",{"property":"og:title","content":"vue"}],["meta",{"property":"og:description","content":"vue 状态 通信 axios qs处理参数 异步 问题 vue父子组件传值不刷新问题 1、在父组件改变子组件的值后，立即调用子组件方法获取最新的值，结果获取不到，获取的是旧值 注意双向绑定和属性绑定的区别，以数据驱动的模型,数据改变组件刷新 解决方案： 1、强制刷新数据，$set,v-if 2、在子组件中监听父组件传入的值，当值改变时进行操作 3、改..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-03-12T18:36:42.000Z"}],["meta",{"property":"article:author","content":"wanhongji"}],["meta",{"property":"article:modified_time","content":"2023-03-12T18:36:42.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"vue\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2023-03-12T18:36:42.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"wanhongji\\"}]}"]]},"headers":[{"level":2,"title":"状态","slug":"状态","link":"#状态","children":[]},{"level":2,"title":"通信","slug":"通信","link":"#通信","children":[]},{"level":2,"title":"异步","slug":"异步","link":"#异步","children":[]},{"level":2,"title":"问题","slug":"问题","link":"#问题","children":[{"level":3,"title":"vue父子组件传值不刷新问题","slug":"vue父子组件传值不刷新问题","link":"#vue父子组件传值不刷新问题","children":[]}]}],"git":{"createdTime":1678646202000,"updatedTime":1678646202000,"contributors":[{"name":"wanhongji","email":"wherywan@163.com","commits":1}]},"readingTime":{"minutes":2.51,"words":753},"filePathRelative":"note/前端/vue.md","localizedDate":"2023年3月12日","excerpt":"\\n<h2>状态</h2>\\n<div class=\\"language-text line-numbers-mode\\" data-ext=\\"text\\" data-title=\\"text\\"><pre class=\\"shiki light-plus\\" style=\\"background-color:#FFFFFF;color:#000000\\" tabindex=\\"0\\"><code><span class=\\"line\\"><span>vuex是vue中的状态管理模式，统一管理多个组件共享的状态。</span></span>\\n<span class=\\"line\\"><span>vuex状态管理模式的核心是store实例相当于应用的仓库，主要有四种属性：</span></span>\\n<span class=\\"line\\"><span>state对象，多组件共享的状态，通过this.$store.的方式或通过辅助函数mapState将state属性映射到组件的计算属性</span></span>\\n<span class=\\"line\\"><span>getters属性，类似于vue的计算属性，它会根据依赖的改变实时变更getter属性的值，即vuex的状态存储是响应式的，通过辅助函数mapGetter将getter属性映射到组件的计算属性</span></span>\\n<span class=\\"line\\"><span>mutations属性类型于有名称的事件，通过commmit方法触发，用于改变store中state的属性状态，通过辅助函数mapMutation将触发方法映射到组件的方法属性，注意mutations是</span></span>\\n<span class=\\"line\\"><span>--同步的，即mutation事件中不可使用回调函数，因为判断不了回调函数何时执行，何时执行完成，进而无法及时变更store中state状态</span></span>\\n<span class=\\"line\\"><span>万物皆对象，函数属性存放的是函数的地址</span></span>\\n<span class=\\"line\\"><span>actions与mutations类似，用于触发mutations事件，且可以执行异步操作，使用await/async,其中dispatch可以处理action事件传回的promise对象，且自己也可以返回promise</span></span>\\n<span class=\\"line\\"><span>--对象，调用then方法执行后续操作,，通过辅助函数mapActions将触发方法dispatch映射到组件的方法属性，</span></span>\\n<span class=\\"line\\"><span>module模块可以解决state对象非常臃肿的问题，使用store.state.模块名.模块名.状态属性访问状态，模块中可以嵌套模块，带有命名空间的模块</span></span>\\n<span class=\\"line\\"><span>可以通过将store实例放入vue根实例的方式将状态实例注入到每一个组件</span></span>\\n<span class=\\"line\\"><span>双向绑定的数据对象的数据对象的数据类型，影响赋值</span></span>\\n<span class=\\"line\\"><span>v-auth权限控制若放在元素首部，可能会失效</span></span>\\n<span class=\\"line\\"><span></span></span></code></pre><div class=\\"line-numbers\\" aria-hidden=\\"true\\"><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div><div class=\\"line-number\\"></div></div></div>","autoDesc":true}');export{u as comp,v as data};
